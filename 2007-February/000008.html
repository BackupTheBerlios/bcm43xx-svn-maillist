<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> r1221 - trunk/sprom
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/bcm43xx-svn/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:bcm43xx-svn%40lists.berlios.de?Subject=Re%3A%20r1221%20-%20trunk/sprom&In-Reply-To=%3C200702172105.l1HL54H7031960%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000007.html">
   <LINK REL="Next"  HREF="000009.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>r1221 - trunk/sprom</H1>
    <B>tuxbuesch at BerliOS</B> 
    <A HREF="mailto:bcm43xx-svn%40lists.berlios.de?Subject=Re%3A%20r1221%20-%20trunk/sprom&In-Reply-To=%3C200702172105.l1HL54H7031960%40sheep.berlios.de%3E"
       TITLE="r1221 - trunk/sprom">tuxbuesch at mail.berlios.de
       </A><BR>
    <I>Sat Feb 17 22:05:04 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000007.html">r1220 - trunk/sprom
</A></li>
        <LI>Next message: <A HREF="000009.html">r1222 - trunk/sprom
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8">[ date ]</a>
              <a href="thread.html#8">[ thread ]</a>
              <a href="subject.html#8">[ subject ]</a>
              <a href="author.html#8">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tuxbuesch
Date: 2007-02-17 22:05:03 +0100 (Sat, 17 Feb 2007)
New Revision: 1221

Added:
   trunk/sprom/ssb_sprom.c
   trunk/sprom/ssb_sprom.h
Removed:
   trunk/sprom/bcm43xx_sprom.c
   trunk/sprom/bcm43xx_sprom.h
Modified:
   trunk/sprom/Makefile
   trunk/sprom/utils.c
   trunk/sprom/utils.h
Log:
rename to ssb-sprom


Modified: trunk/sprom/Makefile
===================================================================
--- trunk/sprom/Makefile	2007-02-17 20:56:53 UTC (rev 1220)
+++ trunk/sprom/Makefile	2007-02-17 21:05:03 UTC (rev 1221)
@@ -6,21 +6,21 @@
 LDFLAGS =
 
 
-OBJECTS = bcm43xx_sprom.o utils.o
+OBJECTS = ssb_sprom.o utils.o
 
 CFLAGS += -DVERSION_=$(VERSION)
 
-all: bcm43xx_sprom
+all: ssb_sprom
 
-bcm43xx_sprom: $(OBJECTS)
-	$(CC) $(CFLAGS) -o bcm43xx-sprom $(OBJECTS) $(LDFLAGS)
+ssb_sprom: $(OBJECTS)
+	$(CC) $(CFLAGS) -o ssb-sprom $(OBJECTS) $(LDFLAGS)
 
 install: all
-	-install -o 0 -g 0 -m 755 bcm43xx-sprom $(PREFIX)/bin/
+	-install -o 0 -g 0 -m 755 ssb-sprom $(PREFIX)/bin/
 
 clean:
-	-rm -f *~ *.o *.orig *.rej bcm43xx-sprom
+	-rm -f *~ *.o *.orig *.rej ssb-sprom
 
 # dependencies
-bcm43xx_sprom.o: bcm43xx_sprom.h utils.h
-utils.o: utils.h bcm43xx_sprom.h
+ssb_sprom.o: ssb_sprom.h utils.h
+utils.o: utils.h ssb_sprom.h

Deleted: trunk/sprom/bcm43xx_sprom.c
===================================================================
--- trunk/sprom/bcm43xx_sprom.c	2007-02-17 20:56:53 UTC (rev 1220)
+++ trunk/sprom/bcm43xx_sprom.c	2007-02-17 21:05:03 UTC (rev 1221)
@@ -1,1420 +0,0 @@
-/*
-
-  Broadcom BCM43xx SPROM data modification tool
-
-  Copyright (c) 2006 Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-svn">mbuesch at freenet.de</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#include &quot;bcm43xx_sprom.h&quot;
-#include &quot;utils.h&quot;
-
-#include &lt;unistd.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;string.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;sys/stat.h&gt;
-
-
-struct cmdline_args cmdargs;
-
-static int value_length_map[] = { /* value to number of bits */
-	[VALUE_RAW] = 8,
-	[VALUE_SUBP] = 16,
-	[VALUE_SUBV] = 16,
-	[VALUE_PPID] = 16,
-	[VALUE_BFLHI] = 16,
-	[VALUE_BFL] = 16,
-	[VALUE_BGMAC] = -1,
-	[VALUE_ETMAC] = -1,
-	[VALUE_AMAC] = -1,
-	[VALUE_ET0PHY] = 8,
-	[VALUE_ET1PHY] = 8,
-	[VALUE_ET0MDC] = 1,
-	[VALUE_ET1MDC] = 1,
-	[VALUE_BREV] = 8,
-	[VALUE_LOC] = 4,
-	[VALUE_ANTA0] = 1,
-	[VALUE_ANTA1] = 1,
-	[VALUE_ANTBG0] = 1,
-	[VALUE_ANTBG1] = 1,
-	[VALUE_ANTGA] = 8,
-	[VALUE_ANTGBG] = 8,
-	[VALUE_PA0B0] = 16,
-	[VALUE_PA0B1] = 16,
-	[VALUE_PA0B2] = 16,
-	[VALUE_PA1B0] = 16,
-	[VALUE_PA1B1] = 16,
-	[VALUE_PA1B2] = 16,
-	[VALUE_WL0GPIO0] = 8,
-	[VALUE_WL0GPIO1] = 8,
-	[VALUE_WL0GPIO2] = 8,
-	[VALUE_WL0GPIO3] = 8,
-	[VALUE_MAXPA] = 8,
-	[VALUE_MAXPBG] = 8,
-	[VALUE_ITSSIA] = 8,
-	[VALUE_ITSSIBG] = 8,
-	[VALUE_SVER] = 8,
-};
-
-
-static int hexdump_sprom(const uint8_t *sprom, char *buffer, size_t bsize)
-{
-	int i, pos = 0;
-
-	for (i = 0; i &lt; SPROM_SIZE; i++) {
-		pos += snprintf(buffer + pos, bsize - pos - 1,
-				&quot;%02X&quot;, sprom[i] &amp; 0xFF);
-	}
-
-	return pos + 1;
-}
-
-static uint8_t sprom_crc(const uint8_t *sprom)
-{
-	int i;
-	uint8_t crc = 0xFF;
-
-	for (i = 0; i &lt; SPROM_SIZE - 1; i++)
-		crc = crc8(crc, sprom[i]);
-	crc ^= 0xFF;
-
-	return crc;
-}
-
-static int write_output_binary(int fd, const uint8_t *sprom)
-{
-	ssize_t w;
-
-	w = write(fd, sprom, SPROM_SIZE);
-	if (w &lt; 0)
-		return -1;
-
-	return 0;
-}
-
-static int write_output_hex(int fd, const uint8_t *sprom)
-{
-	ssize_t w;
-	char tmp[SPROM_SIZE * 2 + 10] = { 0 };
-
-	hexdump_sprom(sprom, tmp, sizeof(tmp));
-	prinfo(&quot;Raw output:  %s\n&quot;, tmp);
-	w = write(fd, tmp, SPROM_SIZE * 2);
-	if (w &lt; 0)
-		return -1;
-
-	return 0;
-}
-
-static int write_output(int fd, const uint8_t *sprom)
-{
-	int err;
-
-	if (cmdargs.outfile) {
-		err = ftruncate(fd, 0);
-		if (err) {
-			prerror(&quot;Could not truncate --outfile %s\n&quot;,
-				cmdargs.outfile);
-			return -1;
-		}
-	}
-
-	if (cmdargs.bin_mode)
-		err = write_output_binary(fd, sprom);
-	else
-		err = write_output_hex(fd, sprom);
-	if (err)
-		prerror(&quot;Could not write output data.\n&quot;);
-
-	return err;
-}
-
-static int modify_value(uint8_t *sprom,
-			struct cmdline_vparm *vparm)
-{
-	const uint16_t v = vparm-&gt;u.value;
-	uint16_t tmp = 0;
-
-	switch (vparm-&gt;type) {
-	case VALUE_RAW:
-		sprom[vparm-&gt;u.raw.offset] = vparm-&gt;u.raw.value;
-		break;
-	case VALUE_SUBP:
-		sprom[SPROM_SUBP + 0] = (v &amp; 0x00FF);
-		sprom[SPROM_SUBP + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
-		break;
-	case VALUE_SUBV:
-		sprom[SPROM_SUBV + 0] = (v &amp; 0x00FF);
-		sprom[SPROM_SUBV + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
-		break;
-	case VALUE_PPID:
-		sprom[SPROM_PPID + 0] = (v &amp; 0x00FF);
-		sprom[SPROM_PPID + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
-		break;
-	case VALUE_BFLHI:
-		sprom[SPROM_BFLHI + 0] = (v &amp; 0x00FF);
-		sprom[SPROM_BFLHI + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
-		break;
-	case VALUE_BFL:
-		sprom[SPROM_BOARDFLAGS + 0] = (v &amp; 0x00FF);
-		sprom[SPROM_BOARDFLAGS + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
-		break;
-	case VALUE_BGMAC:
-		sprom[SPROM_IL0MACADDR + 1] = vparm-&gt;u.mac[0];
-		sprom[SPROM_IL0MACADDR + 0] = vparm-&gt;u.mac[1];
-		sprom[SPROM_IL0MACADDR + 3] = vparm-&gt;u.mac[2];
-		sprom[SPROM_IL0MACADDR + 2] = vparm-&gt;u.mac[3];
-		sprom[SPROM_IL0MACADDR + 5] = vparm-&gt;u.mac[4];
-		sprom[SPROM_IL0MACADDR + 4] = vparm-&gt;u.mac[5];
-		break;
-	case VALUE_ETMAC:
-		sprom[SPROM_ET0MACADDR + 1] = vparm-&gt;u.mac[0];
-		sprom[SPROM_ET0MACADDR + 0] = vparm-&gt;u.mac[1];
-		sprom[SPROM_ET0MACADDR + 3] = vparm-&gt;u.mac[2];
-		sprom[SPROM_ET0MACADDR + 2] = vparm-&gt;u.mac[3];
-		sprom[SPROM_ET0MACADDR + 5] = vparm-&gt;u.mac[4];
-		sprom[SPROM_ET0MACADDR + 4] = vparm-&gt;u.mac[5];
-		break;
-	case VALUE_AMAC:
-		sprom[SPROM_ET1MACADDR + 1] = vparm-&gt;u.mac[0];
-		sprom[SPROM_ET1MACADDR + 0] = vparm-&gt;u.mac[1];
-		sprom[SPROM_ET1MACADDR + 3] = vparm-&gt;u.mac[2];
-		sprom[SPROM_ET1MACADDR + 2] = vparm-&gt;u.mac[3];
-		sprom[SPROM_ET1MACADDR + 5] = vparm-&gt;u.mac[4];
-		sprom[SPROM_ET1MACADDR + 4] = vparm-&gt;u.mac[5];
-		break;
-	case VALUE_ET0PHY:
-		tmp |= sprom[SPROM_ETHPHY + 0];
-		tmp |= sprom[SPROM_ETHPHY + 1] &lt;&lt; 8;
-		tmp = ((tmp &amp; 0x001F) | (v &amp; 0x1F));
-		sprom[SPROM_ETHPHY + 0] = (tmp &amp; 0x00FF);
-		sprom[SPROM_ETHPHY + 1] = (tmp &amp; 0xFF00) &gt;&gt; 8;
-		break;
-	case VALUE_ET1PHY:
-		tmp |= sprom[SPROM_ETHPHY + 0];
-		tmp |= sprom[SPROM_ETHPHY + 1] &lt;&lt; 8;
-		tmp = ((tmp &amp; 0x03E0) | ((v &amp; 0x1F) &lt;&lt; 5));
-		sprom[SPROM_ETHPHY + 0] = (tmp &amp; 0x00FF);
-		sprom[SPROM_ETHPHY + 1] = (tmp &amp; 0xFF00) &gt;&gt; 8;
-		break;
-	case VALUE_ET0MDC:
-		sprom[SPROM_ETHPHY + 1] &amp;= ~(1 &lt;&lt; 6);
-		if (v)
-			sprom[SPROM_ETHPHY + 1] |= (1 &lt;&lt; 6);
-		break;
-	case VALUE_ET1MDC:
-		sprom[SPROM_ETHPHY + 1] &amp;= ~(1 &lt;&lt; 7);
-		if (v)
-			sprom[SPROM_ETHPHY + 1] |= (1 &lt;&lt; 7);
-		break;
-	case VALUE_BREV:
-		sprom[SPROM_BOARDREV + 0] = v;
-		break;
-	case VALUE_LOC:
-		tmp = (sprom[SPROM_BOARDREV + 1] &amp; 0xF0);
-		tmp |= (v &amp; 0x0F);
-		sprom[SPROM_BOARDREV + 1] = (tmp &amp; 0xFF);
-		break;
-	case VALUE_ANTA0:
-		sprom[SPROM_BOARDREV + 1] &amp;= ~(1 &lt;&lt; 4);
-		if (v)
-			sprom[SPROM_BOARDREV + 1] |= (1 &lt;&lt; 4);
-		break;
-	case VALUE_ANTA1:
-		sprom[SPROM_BOARDREV + 1] &amp;= ~(1 &lt;&lt; 5);
-		if (v)
-			sprom[SPROM_BOARDREV + 1] |= (1 &lt;&lt; 5);
-		break;
-	case VALUE_ANTBG0:
-		sprom[SPROM_BOARDREV + 1] &amp;= ~(1 &lt;&lt; 6);
-		if (v)
-			sprom[SPROM_BOARDREV + 1] |= (1 &lt;&lt; 6);
-		break;
-	case VALUE_ANTBG1:
-		sprom[SPROM_BOARDREV + 1] &amp;= ~(1 &lt;&lt; 7);
-		if (v)
-			sprom[SPROM_BOARDREV + 1] |= (1 &lt;&lt; 7);
-		break;
-	case VALUE_ANTGA:
-		sprom[SPROM_ANTENNA_GAIN + 0] = (v &amp; 0xFF);
-		break;
-	case VALUE_ANTGBG:
-		sprom[SPROM_ANTENNA_GAIN + 1] = (v &amp; 0xFF);
-		break;
-	case VALUE_PA0B0:
-		sprom[SPROM_PA0B0 + 0] = (v &amp; 0x00FF);
-		sprom[SPROM_PA0B0 + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
-		break;
-	case VALUE_PA0B1:
-		sprom[SPROM_PA0B1 + 0] = (v &amp; 0x00FF);
-		sprom[SPROM_PA0B1 + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
-		break;
-	case VALUE_PA0B2:
-		sprom[SPROM_PA0B2 + 0] = (v &amp; 0x00FF);
-		sprom[SPROM_PA0B2 + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
-		break;
-	case VALUE_PA1B0:
-		sprom[SPROM_PA1B0 + 0] = (v &amp; 0x00FF);
-		sprom[SPROM_PA1B0 + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
-		break;
-	case VALUE_PA1B1:
-		sprom[SPROM_PA1B1 + 0] = (v &amp; 0x00FF);
-		sprom[SPROM_PA1B1 + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
-		break;
-	case VALUE_PA1B2:
-		sprom[SPROM_PA1B2 + 0] = (v &amp; 0x00FF);
-		sprom[SPROM_PA1B2 + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
-		break;
-	case VALUE_WL0GPIO0:
-		sprom[SPROM_WL0GPIO0 + 0] = (v &amp; 0xFF);
-		break;
-	case VALUE_WL0GPIO1:
-		sprom[SPROM_WL0GPIO0 + 1] = (v &amp; 0xFF);
-		break;
-	case VALUE_WL0GPIO2:
-		sprom[SPROM_WL0GPIO2 + 0] = (v &amp; 0xFF);
-		break;
-	case VALUE_WL0GPIO3:
-		sprom[SPROM_WL0GPIO2 + 1] = (v &amp; 0xFF);
-		break;
-	case VALUE_MAXPA:
-		sprom[SPROM_MAXPWR + 0] = (v &amp; 0xFF);
-		break;
-	case VALUE_MAXPBG:
-		sprom[SPROM_MAXPWR + 1] = (v &amp; 0xFF);
-		break;
-	case VALUE_ITSSIA:
-		sprom[SPROM_IDL_TSSI_TGT + 0] = (v &amp; 0xFF);
-		break;
-	case VALUE_ITSSIBG:
-		sprom[SPROM_IDL_TSSI_TGT + 1] = (v &amp; 0xFF);
-		break;
-	case VALUE_SVER:
-		sprom[SPROM_VERSION + 0] = (v &amp; 0xFF);
-		break;
-	default:
-		prerror(&quot;vparm-&gt;type internal error (0)\n&quot;);
-		exit(1);
-	}
-
-	return 0;
-}
-
-static int modify_sprom(uint8_t *sprom)
-{
-	struct cmdline_vparm *vparm;
-	int i;
-	int modified = 0;
-	uint8_t crc;
-
-	for (i = 0; i &lt; cmdargs.nr_vparm; i++) {
-		vparm = &amp;(cmdargs.vparm[i]);
-		if (!vparm-&gt;set)
-			continue;
-		modify_value(sprom, vparm);
-		modified = 1;
-	}
-	if (modified) {
-		/* Recalculate the CRC. */
-		crc = sprom_crc(sprom);
-		sprom[SPROM_VERSION + 1] = crc;
-	}
-
-	return modified;
-}
-
-static void display_value(const uint8_t *sprom,
-			  struct cmdline_vparm *vparm)
-{
-	const char *desc;
-	uint8_t offset;
-	uint16_t value;
-	uint16_t tmp;
-
-	switch (vparm-&gt;type) {
-	case VALUE_RAW:
-		desc = &quot;RAW&quot;;
-		offset = vparm-&gt;u.raw.offset;
-		value = sprom[offset];
-		break;
-	case VALUE_SUBP:
-		desc = &quot;Subsytem product ID&quot;;
-		offset = SPROM_SUBP;
-		value = sprom[SPROM_SUBP + 0];
-		value |= sprom[SPROM_SUBP + 1] &lt;&lt; 8;
-		break;
-	case VALUE_SUBV:
-		desc = &quot;Subsystem vendor ID&quot;;
-		offset = SPROM_SUBV;
-		value = sprom[SPROM_SUBV + 0];
-		value |= sprom[SPROM_SUBV + 1] &lt;&lt; 8;
-		break;
-	case VALUE_PPID:
-		desc = &quot;PCI Product ID&quot;;
-		offset = SPROM_PPID;
-		value = sprom[SPROM_PPID + 0];
-		value |= sprom[SPROM_PPID + 1] &lt;&lt; 8;
-		break;
-	case VALUE_BFLHI:
-		desc = &quot;High 16 bits of Boardflags&quot;;
-		offset = SPROM_BFLHI;
-		value = sprom[SPROM_BFLHI + 0];
-		value |= sprom[SPROM_BFLHI + 1] &lt;&lt; 8;
-		break;
-	case VALUE_BFL:
-		desc = &quot;Low 16 bits of Boardflags&quot;;
-		offset = SPROM_BOARDFLAGS;
-		value = sprom[SPROM_BOARDFLAGS + 0];
-		value |= sprom[SPROM_BOARDFLAGS + 1] &lt;&lt; 8;
-		break;
-	case VALUE_BGMAC:
-		desc = &quot;MAC address for 802.11b/g&quot;;
-		offset = SPROM_IL0MACADDR;
-		value = 0;
-		break;
-	case VALUE_ETMAC:
-		desc = &quot;MAC address for ethernet&quot;;
-		offset = SPROM_ET0MACADDR;
-		value = 0;
-		break;
-	case VALUE_AMAC:
-		desc = &quot;MAC address for 802.11a&quot;;
-		offset = SPROM_ET1MACADDR;
-		value = 0;
-		break;
-	case VALUE_ET0PHY:
-		desc = &quot;Ethernet phy settings (0)&quot;;
-		offset = SPROM_ETHPHY;
-		tmp = sprom[SPROM_ETHPHY + 0];
-		tmp |= sprom[SPROM_ETHPHY + 1] &lt;&lt; 8;
-		value = (tmp &amp; 0x001F);
-		break;
-	case VALUE_ET1PHY:
-		desc = &quot;Ethernet phy settings (1)&quot;;
-		offset = SPROM_ETHPHY;
-		tmp = sprom[SPROM_ETHPHY + 0];
-		tmp |= sprom[SPROM_ETHPHY + 1] &lt;&lt; 8;
-		value = (tmp &amp; 0x03E0) &gt;&gt; 5;
-		break;
-	case VALUE_ET0MDC:
-		desc = &quot;et0mdcport&quot;;
-		offset = SPROM_ETHPHY + 1;
-		value = 0;
-		if (sprom[SPROM_ETHPHY + 1] &amp; (1 &lt;&lt; 6))
-			value = 1;
-		break;
-	case VALUE_ET1MDC:
-		desc = &quot;et1mdcport&quot;;
-		offset = SPROM_ETHPHY + 1;
-		value = 0;
-		if (sprom[SPROM_ETHPHY + 1] &amp; (1 &lt;&lt; 7))
-			value = 1;
-		break;
-	case VALUE_BREV:
-		desc = &quot;Board revision&quot;;
-		offset = SPROM_BOARDREV;
-		value = sprom[SPROM_BOARDREV + 0];
-		break;
-	case VALUE_LOC:
-		desc = &quot;Locale / Country Code&quot;;
-		offset = SPROM_BOARDREV + 1;
-		value = (sprom[SPROM_BOARDREV + 1] &amp; 0x0F);
-		break;
-	case VALUE_ANTA0:
-		desc = &quot;A PHY antenna 0 available&quot;;
-		offset = SPROM_BOARDREV + 1;
-		value = 0;
-		if (sprom[SPROM_BOARDREV + 1] &amp; (1 &lt;&lt; 4))
-			value = 1;
-		break;
-	case VALUE_ANTA1:
-		desc = &quot;A PHY antenna 1 available&quot;;
-		offset = SPROM_BOARDREV + 1;
-		value = 0;
-		if (sprom[SPROM_BOARDREV + 1] &amp; (1 &lt;&lt; 5))
-			value = 1;
-		break;
-	case VALUE_ANTBG0:
-		desc = &quot;B/G PHY antenna 1 available&quot;;
-		offset = SPROM_BOARDREV + 1;
-		value = 0;
-		if (sprom[SPROM_BOARDREV + 1] &amp; (1 &lt;&lt; 6))
-			value = 1;
-		break;
-	case VALUE_ANTBG1:
-		desc = &quot;B/G PHY antenna 1 available&quot;;
-		offset = SPROM_BOARDREV + 1;
-		value = 0;
-		if (sprom[SPROM_BOARDREV + 1] &amp; (1 &lt;&lt; 7))
-			value = 1;
-		break;
-	case VALUE_ANTGA:
-		desc = &quot;A PHY antenna gain&quot;;
-		offset = SPROM_ANTENNA_GAIN;
-		value = sprom[SPROM_ANTENNA_GAIN];
-		break;
-	case VALUE_ANTGBG:
-		desc = &quot;A PHY antenna gain&quot;;
-		offset = SPROM_ANTENNA_GAIN + 1;
-		value = sprom[SPROM_ANTENNA_GAIN + 1];
-		break;
-	case VALUE_PA0B0:
-		desc = &quot;pa0b0&quot;;
-		offset = SPROM_PA0B0;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] &lt;&lt; 8;
-		break;
-	case VALUE_PA0B1:
-		desc = &quot;pa0b1&quot;;
-		offset = SPROM_PA0B1;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] &lt;&lt; 8;
-		break;
-	case VALUE_PA0B2:
-		desc = &quot;pa0b2&quot;;
-		offset = SPROM_PA0B2;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] &lt;&lt; 8;
-		break;
-	case VALUE_PA1B0:
-		desc = &quot;pa1b0&quot;;
-		offset = SPROM_PA1B0;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] &lt;&lt; 8;
-		break;
-	case VALUE_PA1B1:
-		desc = &quot;pa1b1&quot;;
-		offset = SPROM_PA1B1;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] &lt;&lt; 8;
-		break;
-	case VALUE_PA1B2:
-		desc = &quot;pa1b2&quot;;
-		offset = SPROM_PA1B2;
-		value = sprom[offset + 0];
-		value |= sprom[offset + 1] &lt;&lt; 8;
-		break;
-	case VALUE_WL0GPIO0:
-		desc = &quot;LED 0 behaviour&quot;;
-		offset = SPROM_WL0GPIO0 + 0;
-		value = sprom[offset];
-		break;
-	case VALUE_WL0GPIO1:
-		desc = &quot;LED 1 behaviour&quot;;
-		offset = SPROM_WL0GPIO0 + 1;
-		value = sprom[offset];
-		break;
-	case VALUE_WL0GPIO2:
-		desc = &quot;LED 2 behaviour&quot;;
-		offset = SPROM_WL0GPIO2 + 0;
-		value = sprom[offset];
-		break;
-	case VALUE_WL0GPIO3:
-		desc = &quot;LED 3 behaviour&quot;;
-		offset = SPROM_WL0GPIO2 + 1;
-		value = sprom[offset];
-		break;
-	case VALUE_MAXPA:
-		desc = &quot;A PHY max powerout&quot;;
-		offset = SPROM_MAXPWR + 0;
-		value = sprom[offset];
-		break;
-	case VALUE_MAXPBG:
-		desc = &quot;B/G PHY max powerout&quot;;
-		offset = SPROM_MAXPWR + 1;
-		value = sprom[offset];
-		break;
-	case VALUE_ITSSIA:
-		desc = &quot;A PHY idle TSSI target&quot;;
-		offset = SPROM_IDL_TSSI_TGT + 0;
-		value = sprom[offset];
-		break;
-	case VALUE_ITSSIBG:
-		desc = &quot;B/G PHY idle TSSI target&quot;;
-		offset = SPROM_IDL_TSSI_TGT + 1;
-		value = sprom[offset];
-		break;
-	case VALUE_SVER:
-		desc = &quot;SPROM version&quot;;
-		offset = SPROM_VERSION;
-		value = sprom[offset];
-		break;
-	default:
-		prerror(&quot;vparm-&gt;type internal error (1)\n&quot;);
-		exit(1);
-	}
-
-	switch (vparm-&gt;bits) {
-	case 1:
-		prdata(&quot;SPROM(0x%02X, %s) = %s\n&quot;,
-		       offset, desc, value ? &quot;ON&quot; : &quot;OFF&quot;);
-		break;
-	case 4:
-		prdata(&quot;SPROM(0x%02X, %s) = 0x%01X\n&quot;,
-		       offset, desc, (value &amp; 0xF));
-		break;
-	case 8:
-		prdata(&quot;SPROM(0x%02X, %s) = 0x%02X\n&quot;,
-		       offset, desc, (value &amp; 0xFF));
-		break;
-	case 16:
-		prdata(&quot;SPROM(0x%02X, %s) = 0x%04X\n&quot;,
-		       offset, desc, (value &amp; 0xFFFF));
-		break;
-	case -1: {
-		/* MAC address. */
-		const uint8_t *p = &amp;(sprom[offset]);
-
-		prdata(&quot;SPROM(0x%02X, %s) = %02x:%02x:%02x:%02x:%02x:%02x\n&quot;,
-		       offset, desc,
-		       p[1], p[0], p[3], p[2], p[5], p[4]);
-		break;
-	}
-	default:
-		prerror(&quot;vparm-&gt;bits internal error (%d)\n&quot;,
-			vparm-&gt;bits);
-		exit(1);
-	}
-}
-
-static int display_sprom(const uint8_t *sprom)
-{
-	struct cmdline_vparm *vparm;
-	int i;
-
-	for (i = 0; i &lt; cmdargs.nr_vparm; i++) {
-		vparm = &amp;(cmdargs.vparm[i]);
-		if (vparm-&gt;set)
-			continue;
-		display_value(sprom, vparm);
-	}
-
-	return 0;
-}
-
-static int validate_input(const uint8_t *sprom)
-{
-	uint8_t crc, expected_crc;
-
-	crc = sprom_crc(sprom);
-	expected_crc = sprom[SPROM_VERSION + 1];
-	if (crc != expected_crc) {
-		prerror(&quot;Corrupt input data (crc: 0x%02X, expected: 0x%02X)\n&quot;,
-			crc, expected_crc);
-		if (!cmdargs.force)
-			return 1;
-	}
-
-	return 0;
-}
-
-static int parse_input(uint8_t *sprom, char *buffer, size_t bsize)
-{
-	char *input;
-	size_t inlen;
-	size_t cnt;
-	unsigned long parsed;
-	char tmp[SPROM_SIZE * 2 + 10] = { 0 };
-
-	if (cmdargs.bin_mode) {
-		/* The input buffer already contains
-		 * the binary sprom data.
-		 */
-		internal_error_on(bsize != SPROM_SIZE);
-		memcpy(sprom, buffer, SPROM_SIZE);
-		return 0;
-	}
-
-	inlen = bsize;
-	input = strchr(buffer, ':');
-	if (input) {
-		input++;
-		inlen -= input - buffer;
-	} else
-		input = buffer;
-
-	if (inlen &lt; SPROM_SIZE * 2) {
-		prerror(&quot;Input data too short\n&quot;);
-		return -1;
-	}
-	for (cnt = 0; cnt &lt; SPROM_SIZE; cnt++) {
-		memcpy(tmp, input + cnt * 2, 2);
-		parsed = strtoul(tmp, NULL, 16);
-		sprom[cnt] = parsed &amp; 0xFF;
-	}
-
-	if (cmdargs.verbose) {
-		hexdump_sprom(sprom, tmp, sizeof(tmp));
-		prinfo(&quot;Raw input:  %s\n&quot;, tmp);
-	}
-
-	return 0;
-}
-
-static int read_infile(int fd, char **buffer, size_t *bsize)
-{
-	struct stat s;
-	int err;
-	ssize_t r;
-
-	err = fstat(fd, &amp;s);
-	if (err) {
-		prerror(&quot;Could not stat input file.\n&quot;);
-		return err;
-	}
-	if (s.st_size == 0) {
-		prerror(&quot;No input data\n&quot;);
-		return -1;
-	}
-	if (cmdargs.bin_mode) {
-		if (s.st_size != SPROM_SIZE) {
-			prerror(&quot;The input data is no SPROM Binary data. &quot;
-				&quot;The size must be exactly %d bytes, &quot;
-				&quot;but it is %u bytes\n&quot;,
-				SPROM_SIZE, (unsigned int)(s.st_size));
-			return -1;
-		}
-	} else {
-		if (s.st_size &gt; 1024 * 1024) {
-			prerror(&quot;The input data does not look &quot;
-				&quot;like SPROM HEX data (too long).\n&quot;);
-			return -1;
-		}
-	}
-
-	*bsize = s.st_size;
-	if (!cmdargs.bin_mode)
-		(*bsize)++;
-	*buffer = malloce(*bsize);
-	r = read(fd, *buffer, s.st_size);
-	if (r != s.st_size) {
-		prerror(&quot;Could not read input data.\n&quot;);
-		return -1;
-	}
-	if (!cmdargs.bin_mode)
-		(*buffer)[r] = '\0';
-
-	return 0;
-}
-
-static void close_infile(int fd)
-{
-	if (cmdargs.infile)
-		close(fd);
-}
-
-static void close_outfile(int fd)
-{
-	if (cmdargs.outfile)
-		close(fd);
-}
-
-static int open_infile(int *fd)
-{
-	*fd = STDIN_FILENO;
-	if (!cmdargs.infile)
-		return 0;
-	*fd = open(cmdargs.infile, O_RDONLY);
-	if (*fd &lt; 0) {
-		prerror(&quot;Could not open --infile %s\n&quot;,
-			cmdargs.infile);
-		return -1;
-	}
-
-	return 0;
-}
-
-static int open_outfile(int *fd)
-{
-	*fd = STDOUT_FILENO;
-	if (!cmdargs.outfile)
-		return 0;
-	*fd = open(cmdargs.outfile, O_RDWR | O_CREAT, 0644);
-	if (*fd &lt; 0) {
-		prerror(&quot;Could not open --outfile %s\n&quot;,
-			cmdargs.outfile);
-		return -1;
-	}
-
-	return 0;
-}
-
-static void print_banner(int forceprint)
-{
-	const char *str = &quot;BCM43xx SPROM data modification tool version &quot; VERSION &quot;\n&quot;;
-	if (forceprint)
-		prdata(str);
-	else
-		prinfo(str);
-}
-
-static void print_usage(int argc, char *argv[])
-{
-	print_banner(1);
-	prdata(&quot;\nUsage: %s [OPTION]\n&quot;, argv[0]);
-	prdata(&quot;  -i|--input FILE       Input file\n&quot;);
-	prdata(&quot;  -o|--output FILE      Output file\n&quot;);
-	prdata(&quot;  -b|--binmode          The Input data is plain binary data and Output will be binary\n&quot;);
-	prdata(&quot;  -V|--verbose          Be verbose\n&quot;);
-	prdata(&quot;  -f|--force            Override error checks\n&quot;);
-	prdata(&quot;  -v|--version          Print version\n&quot;);
-	prdata(&quot;  -h|--help             Print this help\n&quot;);
-	prdata(&quot;\n&quot;);
-	prdata(&quot;Value Parameters:\n&quot;);
-	prdata(&quot;\n&quot;);
-	prdata(&quot;  -s|--rawset OFF,VAL   Set a VALue at a byte-OFFset\n&quot;);
-	prdata(&quot;  -g|--rawget OFF       Get a value at a byte-OFFset\n&quot;);
-	prdata(&quot;\n&quot;);
-	prdata(&quot;Predefined values (for displaying (GET) or modification):\n&quot;);
-	prdata(&quot;  --subp [0xFFFF]       Subsytem product ID for PCI\n&quot;);
-	prdata(&quot;  --subv [0xFFFF]       Subsystem vendor ID for PCI\n&quot;);
-	prdata(&quot;  --ppid [0xFFFF]       Product ID for PCI\n&quot;);
-	prdata(&quot;  --bflhi [0xFFFF]      High 16 bits of boardflags (only if spromversion &gt; 1)\n&quot;);
-	prdata(&quot;  --bfl [0xFFFF]        Low 16 bits of boardflags\n&quot;);
-	prdata(&quot;  --bgmac [MAC-ADDR]    MAC address for 802.11b/g\n&quot;);
-	prdata(&quot;  --etmac [MAC-ADDR]    MAC address for ethernet, see b44 driver\n&quot;);
-	prdata(&quot;  --amac [MAC-ADDR]     Mac address for 802.11a\n&quot;);
-	prdata(&quot;  --et0phy [0xFF]\n&quot;);
-	prdata(&quot;  --et1phy [0xFF]\n&quot;);
-	prdata(&quot;  --et0mdc [BOOL]\n&quot;);
-	prdata(&quot;  --et1mdc [BOOL]\n&quot;);
-	prdata(&quot;  --brev [0xFF]         Board revision\n&quot;);
-	prdata(&quot;  --loc [0xF]           Country code\n&quot;);
-	prdata(&quot;  --anta0 [BOOL]        Antenna 0 available for A PHY\n&quot;);
-	prdata(&quot;  --anta1 [BOOL]        Antenna 1 available for A PHY\n&quot;);
-	prdata(&quot;  --antbg0 [BOOL]       Antenna 0 available for B/G PHY\n&quot;);
-	prdata(&quot;  --antbg1 [BOOL]       Antenna 1 available for B/G PHY\n&quot;);
-	prdata(&quot;  --antga [0xFF]        Antenna gain for A PHY\n&quot;);
-	prdata(&quot;  --antgbg [0xFF]       Antenna gain for B/G PHY\n&quot;);
-	prdata(&quot;  --pa0b0 [0xFFFF]\n&quot;);
-	prdata(&quot;  --pa0b1 [0xFFFF]\n&quot;);
-	prdata(&quot;  --pa0b2 [0xFFFF]\n&quot;);
-	prdata(&quot;  --pa1b0 [0xFFFF]\n&quot;);
-	prdata(&quot;  --pa1b1 [0xFFFF]\n&quot;);
-	prdata(&quot;  --pa1b2 [0xFFFF]\n&quot;);
-	prdata(&quot;  --wl0gpio0 [0xFF]     LED 0 behaviour\n&quot;);
-	prdata(&quot;  --wl0gpio1 [0xFF]     LED 1 behaviour\n&quot;);
-	prdata(&quot;  --wl0gpio2 [0xFF]     LED 2 behaviour\n&quot;);
-	prdata(&quot;  --wl0gpio3 [0xFF]     LED 3 behaviour\n&quot;);
-	prdata(&quot;  --maxpa [0xFF]        A PHY max power\n&quot;);
-	prdata(&quot;  --maxpbg [0xFF]       B/G PHY max power\n&quot;);
-	prdata(&quot;  --itssia [0xFF]       Idle tssi target for A PHY\n&quot;);
-	prdata(&quot;  --itssibg [0xFF]      Idle tssi target for B/G PHY\n&quot;);
-	prdata(&quot;  --sver [0xFF]         SPROM-version\n&quot;);
-	prdata(&quot;\n&quot;);
-	prdata(&quot;  -P|--print-all        Display all values\n&quot;);
-	prdata(&quot;\n&quot;);
-	prdata(&quot; BOOL      is a boolean value. Either 0 or 1\n&quot;);
-	prdata(&quot; 0xF..     is a hexadecimal value\n&quot;);
-	prdata(&quot; MAC-ADDR  is a MAC address in the format 00:00:00:00:00:00\n&quot;);
-	prdata(&quot; If the value parameter is \&quot;GET\&quot;, the value will be printed;\n&quot;);
-	prdata(&quot; otherwise it is modified.\n&quot;);
-}
-
-#define ARG_MATCH		0
-#define ARG_NOMATCH		1
-#define ARG_ERROR		-1
-
-static int do_cmp_arg(char **argv, int *pos,
-		      const char *template,
-		      int allow_merged,
-		      char **param)
-{
-	char *arg;
-	char *next_arg;
-	size_t arg_len, template_len;
-
-	arg = argv[*pos];
-	next_arg = argv[*pos + 1];
-	arg_len = strlen(arg);
-	template_len = strlen(template);
-
-	if (param) {
-		/* Maybe we have a merged parameter here.
-		 * A merged parameter is &quot;-pfoobar&quot; for example.
-		 */
-		if (allow_merged &amp;&amp; arg_len &gt; template_len) {
-			if (memcmp(arg, template, template_len) == 0) {
-				*param = arg + template_len;
-				return ARG_MATCH;
-			}
-			return ARG_NOMATCH;
-		} else if (arg_len != template_len)
-			return ARG_NOMATCH;
-		*param = next_arg;
-	}
-	if (strcmp(arg, template) == 0) {
-		if (param) {
-			/* Skip the parameter on the next iteration. */
-			(*pos)++;
-			if (*param == 0) {
-				prerror(&quot;%s needs a parameter\n&quot;, arg);
-				return ARG_ERROR;
-			}
-		}
-		return ARG_MATCH;
-	}
-
-	return ARG_NOMATCH;
-}
-
-/* Simple and lean command line argument parsing. */
-static int cmp_arg(char **argv, int *pos,
-		   const char *long_template,
-		   const char *short_template,
-		   char **param)
-{
-	int err;
-
-	if (long_template) {
-		err = do_cmp_arg(argv, pos, long_template, 0, param);
-		if (err == ARG_MATCH || err == ARG_ERROR)
-			return err;
-	}
-	err = ARG_NOMATCH;
-	if (short_template)
-		err = do_cmp_arg(argv, pos, short_template, 1, param);
-	return err;
-}
-
-static int parse_err;
-
-static int arg_match(char **argv, int *i,
-		     const char *long_template,
-		     const char *short_template,
-		     char **param)
-{
-	int res;
-
-	res = cmp_arg(argv, i, long_template,
-		      short_template, param);
-	if (res == ARG_ERROR) {
-		parse_err = 1;
-		return 0;
-	}
-	return (res == ARG_MATCH);
-}
-
-static int parse_value(const char *str,
-		       struct cmdline_vparm *vparm,
-		       const char *param)
-{
-	unsigned long v;
-	int i;
-
-	vparm-&gt;bits = value_length_map[vparm-&gt;type];
-	vparm-&gt;set = 1;
-	if (strcmp(str, &quot;GET&quot;) == 0 || strcmp(str, &quot;get&quot;) == 0) {
-		vparm-&gt;set = 0;
-		return 0;
-	}
-	if (vparm-&gt;bits == 1) {
-		/* This is a boolean value. */
-		if (strcmp(str, &quot;0&quot;) == 0)
-			vparm-&gt;u.value = 0;
-		else if (strcmp(str, &quot;1&quot;) == 0)
-			vparm-&gt;u.value = 1;
-		else
-			goto error_bool;
-		return 1;
-	}
-
-	if (strncmp(str, &quot;0x&quot;, 2) != 0)
-		goto error;
-	str += 2;
-	for (i = 0; i &lt; vparm-&gt;bits / 4; i++) {
-		if (str[i] == '\0')
-			goto error;
-	}
-	if (str[i] != '\0')
-		goto error;
-	errno = 0;
-	v = strtoul(str, NULL, 16);
-	if (errno)
-		goto error;
-	vparm-&gt;u.value = v;
-
-	return 1;
-error:
-	if (param) {
-		prerror(&quot;%s value parsing error. Format: 0x&quot;, param);
-		for (i = 0; i &lt; vparm-&gt;bits / 4; i++)
-			prerror(&quot;F&quot;);
-		prerror(&quot;\n&quot;);
-	}
-	return -1;
-
-error_bool:
-	if (param)
-		prerror(&quot;%s value parsing error. Format: 0 or 1 (boolean)\n&quot;, param);
-	return -1;
-}
-
-static int parse_mac(const char *str,
-		     struct cmdline_vparm *vparm,
-		     const char *param)
-{
-	int i;
-	char *delim;
-	const char *in = str;
-	uint8_t *out = vparm-&gt;u.mac;
-
-	vparm-&gt;bits = -1;
-	vparm-&gt;set = 1;
-	if (strcmp(str, &quot;GET&quot;) == 0 || strcmp(str, &quot;get&quot;) == 0) {
-		vparm-&gt;set = 0;
-		return 0;
-	}
-
-	for (i = 0; ; i++) {
-		errno = 0;
-		out[i] = strtoul(in, NULL, 16);
-		if (errno)
-			goto error;
-		if (i == 5) {
-			if (in[1] != '\0' &amp;&amp; in[2] != '\0')
-				goto error;
-			break;
-		}
-		delim = strchr(in, ':');
-		if (!delim)
-			goto error;
-		in = delim + 1;
-	}
-
-	return 1;
-error:
-	prerror(&quot;%s MAC parsing error. Format: 00:00:00:00:00:00\n&quot;, param);
-	return -1;
-}
-
-static int parse_rawset(const char *str,
-			struct cmdline_vparm *vparm)
-{
-	char *delim;
-	uint8_t value;
-	uint8_t offset;
-	int err;
-
-	vparm-&gt;type = VALUE_RAW;
-
-	delim = strchr(str, ',');
-	if (!delim)
-		goto error;
-	*delim = '\0';
-	err = parse_value(str, vparm, NULL);
-	if (err != 1)
-		goto error;
-	offset = vparm-&gt;u.value;
-	if (offset &gt;= SPROM_SIZE) {
-		prerror(&quot;--rawset offset too big (&gt;= 0x%02X)\n&quot;,
-			SPROM_SIZE);
-		return -1;
-	}
-	err = parse_value(delim + 1, vparm, NULL);
-	if (err != 1)
-		goto error;
-	value = vparm-&gt;u.value;
-
-	vparm-&gt;u.raw.value = value;
-	vparm-&gt;u.raw.offset = offset;
-	vparm-&gt;set = 1;
-
-	return 0;
-error:
-	prerror(&quot;--rawset value parsing error. Format: 0xFF,0xFF &quot;
-		&quot;(first Offset, second Value)\n&quot;);
-	return -1;
-}
-
-static int parse_rawget(const char *str,
-			struct cmdline_vparm *vparm)
-{
-	int err;
-	uint8_t offset;
-
-	vparm-&gt;type = VALUE_RAW;
-
-	err = parse_value(str, vparm, &quot;--rawget&quot;);
-	if (err != 1)
-		return -1;
-	offset = vparm-&gt;u.value;
-	if (offset &gt;= SPROM_SIZE) {
-		prerror(&quot;--rawget offset too big (&gt;= 0x%02X)\n&quot;,
-			SPROM_SIZE);
-		return -1;
-	}
-
-	vparm-&gt;u.raw.offset = offset;
-	vparm-&gt;type = VALUE_RAW;
-	vparm-&gt;set = 0;
-
-	return 0;
-}
-
-static int generate_printall(void)
-{
-	struct cmdline_vparm *vparm;
-	int count, i;
-	enum valuetype vt = VALUE_FIRST;
-
-	count = VALUE_LAST - VALUE_FIRST + 1;
-	for (i = 0; i &lt; count; i++, vt++) {
-		if (cmdargs.nr_vparm == MAX_VPARM) {
-			prerror(&quot;Too many value parameters.\n&quot;);
-			return -1;
-		}
-
-		vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-		vparm-&gt;type = vt;
-		vparm-&gt;set = 0;
-		vparm-&gt;bits = value_length_map[vt];
-	}
-
-	return 0;
-}
-
-static int parse_args(int argc, char *argv[])
-{
-	struct cmdline_vparm *vparm;
-	int i, err;
-	char *param;
-
-	parse_err = 0;
-	for (i = 1; i &lt; argc; i++) {
-		if (cmdargs.nr_vparm == MAX_VPARM) {
-			prerror(&quot;Too many value parameters.\n&quot;);
-			return -1;
-		}
-
-		if (arg_match(argv, &amp;i, &quot;--version&quot;, &quot;-v&quot;, 0)) {
-			print_banner(1);
-			return 1;
-		} else if (arg_match(argv, &amp;i, &quot;--help&quot;, &quot;-h&quot;, 0)) {
-			goto out_usage;
-		} else if (arg_match(argv, &amp;i, &quot;--input&quot;, &quot;-i&quot;, &amp;param)) {
-			cmdargs.infile = param;
-		} else if (arg_match(argv, &amp;i, &quot;--output&quot;, &quot;-o&quot;, &amp;param)) {
-			cmdargs.outfile = param;
-		} else if (arg_match(argv, &amp;i, &quot;--verbose&quot;, &quot;-V&quot;, 0)) {
-			cmdargs.verbose = 1;
-		} else if (arg_match(argv, &amp;i, &quot;--force&quot;, &quot;-n&quot;, 0)) {
-			cmdargs.force = 1;
-		} else if (arg_match(argv, &amp;i, &quot;--binmode&quot;, &quot;-b&quot;, 0)) {
-			cmdargs.bin_mode = 1;
-
-
-		} else if (arg_match(argv, &amp;i, &quot;--rawset&quot;, &quot;-s&quot;, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			err = parse_rawset(param, vparm);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--rawget&quot;, &quot;-g&quot;, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			err = parse_rawget(param, vparm);
-			if (err &lt; 0)
-				goto error;
-
-
-		} else if (arg_match(argv, &amp;i, &quot;--subp&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_SUBP;
-			err = parse_value(param, vparm, &quot;--subp&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--subv&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_SUBV;
-			err = parse_value(param, vparm, &quot;--subv&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--ppid&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_PPID;
-			err = parse_value(param, vparm, &quot;--ppid&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--bflhi&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_BFLHI;
-			err = parse_value(param, vparm, &quot;--bflhi&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--bfl&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_BFL;
-			err = parse_value(param, vparm, &quot;--bfl&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--bgmac&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_BGMAC;
-			err = parse_mac(param, vparm, &quot;--bgmac&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--etmac&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_ETMAC;
-			err = parse_mac(param, vparm, &quot;--etmac&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--amac&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_AMAC;
-			err = parse_mac(param, vparm, &quot;--amac&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--et0phy&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_ET0PHY;
-			err = parse_value(param, vparm, &quot;--et0phy&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--et1phy&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_ET1PHY;
-			err = parse_value(param, vparm, &quot;--et1phy&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--et0mdc&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_ET0MDC;
-			err = parse_value(param, vparm, &quot;--et0mdc&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--et1mdc&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_ET1MDC;
-			err = parse_value(param, vparm, &quot;--et1mdc&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--brev&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_BREV;
-			err = parse_value(param, vparm, &quot;--brev&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--loc&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_LOC;
-			err = parse_value(param, vparm, &quot;--loc&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--anta0&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_ANTA0;
-			err = parse_value(param, vparm, &quot;--anta0&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--anta1&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_ANTA1;
-			err = parse_value(param, vparm, &quot;--anta1&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--antbg0&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_ANTBG0;
-			err = parse_value(param, vparm, &quot;--antbg0&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--antbg1&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_ANTBG1;
-			err = parse_value(param, vparm, &quot;--antbg1&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--antga&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_ANTGA;
-			err = parse_value(param, vparm, &quot;--antga&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--antgbg&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_ANTGBG;
-			err = parse_value(param, vparm, &quot;--antgbg&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--pa0b0&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_PA0B0;
-			err = parse_value(param, vparm, &quot;--pa0b0&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--pa0b1&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_PA0B1;
-			err = parse_value(param, vparm, &quot;--pa0b1&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--pa0b2&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_PA0B2;
-			err = parse_value(param, vparm, &quot;--pa0b2&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--pa1b0&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_PA1B0;
-			err = parse_value(param, vparm, &quot;--pa1b0&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--pa1b1&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_PA1B1;
-			err = parse_value(param, vparm, &quot;--pa1b1&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--pa1b2&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_PA1B2;
-			err = parse_value(param, vparm, &quot;--pa1b2&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--wl0gpio0&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_WL0GPIO0;
-			err = parse_value(param, vparm, &quot;--wl0gpio0&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--wl0gpio1&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_WL0GPIO1;
-			err = parse_value(param, vparm, &quot;--wl0gpio1&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--wl0gpio2&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_WL0GPIO2;
-			err = parse_value(param, vparm, &quot;--wl0gpio2&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--wl0gpio3&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_WL0GPIO3;
-			err = parse_value(param, vparm, &quot;--wl0gpio3&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--maxpa&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_MAXPA;
-			err = parse_value(param, vparm, &quot;--maxpa&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--maxpbg&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_MAXPBG;
-			err = parse_value(param, vparm, &quot;--maxpbg&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--itssia&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_ITSSIA;
-			err = parse_value(param, vparm, &quot;--itssia&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--itssibg&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_ITSSIBG;
-			err = parse_value(param, vparm, &quot;--itssibg&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--sver&quot;, 0, &amp;param)) {
-			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
-			vparm-&gt;type = VALUE_SVER;
-			err = parse_value(param, vparm, &quot;--sver&quot;);
-			if (err &lt; 0)
-				goto error;
-		} else if (arg_match(argv, &amp;i, &quot;--print-all&quot;, &quot;-P&quot;, 0)) {
-			err = generate_printall();
-			if (err)
-				goto error;
-		} else {
-			prerror(&quot;Unrecognized argument: %s\n&quot;, argv[i]);
-			goto out_usage;
-		}
-		if (parse_err)
-			goto out_usage;
-	}
-	if (cmdargs.nr_vparm == 0) {
-		prerror(&quot;No Value parameter given. See --help.\n&quot;);
-		return -1;
-	}
-	return 0;
-
-out_usage:
-	print_usage(argc, argv);
-error:
-	return -1;	
-}
-
-
-int main(int argc, char **argv)
-{
-	int err;
-	int fd;
-	uint8_t sprom[SPROM_SIZE];
-	char *buffer = NULL;
-	size_t buffer_size = 0;
-
-	err = parse_args(argc, argv);
-	if (err == 1)
-		return 0;
-	else if (err != 0)
-		goto out;
-
-	print_banner(0);
-	prinfo(&quot;\nReading input from \&quot;%s\&quot;...\n&quot;,
-	       cmdargs.infile ? cmdargs.infile : &quot;stdin&quot;);
-
-	err = open_infile(&amp;fd);
-	if (err)
-		goto out;
-	err = read_infile(fd, &amp;buffer, &amp;buffer_size);
-	close_infile(fd);
-	if (err)
-		goto out;
-	err = parse_input(sprom, buffer, buffer_size);
-	free(buffer);
-	if (err)
-		goto out;
-	err = validate_input(sprom);
-	if (err)
-		goto out;
-
-	err = display_sprom(sprom);
-	if (err)
-		goto out;
-	err = modify_sprom(sprom);
-	if (err &lt; 0)
-		goto out;
-	if (err) {
-		err = open_outfile(&amp;fd);
-		if (err)
-			goto out;
-		err = write_output(fd, sprom);
-		close_outfile(fd);
-		if (err)
-			goto out;
-		prinfo(&quot;SPROM modified.\n&quot;);
-	}
-out:
-	return err;
-}

Deleted: trunk/sprom/bcm43xx_sprom.h
===================================================================
--- trunk/sprom/bcm43xx_sprom.h	2007-02-17 20:56:53 UTC (rev 1220)
+++ trunk/sprom/bcm43xx_sprom.h	2007-02-17 21:05:03 UTC (rev 1221)
@@ -1,126 +0,0 @@
-/*
-
-  Broadcom BCM43xx SPROM data modification tool
-
-  Copyright (c) 2006 Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-svn">mbuesch at freenet.de</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; see the file COPYING.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
-  Boston, MA 02110-1301, USA.
-
-*/
-
-#ifndef BCM43xx_SPROMTOOL_H_
-#define BCM43xx_SPROMTOOL_H_
-
-#include &quot;utils.h&quot;
-
-#define VERSION			bcm43xx_stringify(VERSION_)
-
-#define SPROM_SIZE		128 /* bytes */
-
-/* byte offsets */
-#define SPROM_SUBP		(0x02 * 2)
-#define SPROM_SUBV		(0x03 * 2)
-#define SPROM_PPID		(0x04 * 2)
-#define SPROM_BFLHI		(0x1C * 2)
-#define SPROM_IL0MACADDR	(0x24 * 2)
-#define SPROM_ET0MACADDR	(0x27 * 2)
-#define SPROM_ET1MACADDR	(0x2a * 2)
-#define SPROM_ETHPHY		(0x2d * 2)
-#define SPROM_BOARDREV		(0x2e * 2)
-#define SPROM_PA0B0		(0x2f * 2)
-#define SPROM_PA0B1		(0x30 * 2)
-#define SPROM_PA0B2		(0x31 * 2)
-#define SPROM_WL0GPIO0		(0x32 * 2)
-#define SPROM_WL0GPIO2		(0x33 * 2)
-#define SPROM_MAXPWR		(0x34 * 2)
-#define SPROM_PA1B0		(0x35 * 2)
-#define SPROM_PA1B1		(0x36 * 2)
-#define SPROM_PA1B2		(0x37 * 2)
-#define SPROM_IDL_TSSI_TGT	(0x38 * 2)
-#define SPROM_BOARDFLAGS	(0x39 * 2)
-#define SPROM_ANTENNA_GAIN	(0x3a * 2)
-#define SPROM_VERSION		(0x3f * 2)
-
-enum valuetype {
-	VALUE_RAW,
-
-	VALUE_SUBP,
- VALUE_FIRST = VALUE_SUBP,
-	VALUE_SUBV,
-	VALUE_PPID,
-	VALUE_BFLHI,
-	VALUE_BFL,
-	VALUE_BGMAC,
-	VALUE_ETMAC,
-	VALUE_AMAC,
-	VALUE_ET0PHY,
-	VALUE_ET1PHY,
-	VALUE_ET0MDC,
-	VALUE_ET1MDC,
-	VALUE_BREV,
-	VALUE_LOC,
-	VALUE_ANTA0,
-	VALUE_ANTA1,
-	VALUE_ANTBG0,
-	VALUE_ANTBG1,
-	VALUE_ANTGA,
-	VALUE_ANTGBG,
-	VALUE_PA0B0,
-	VALUE_PA0B1,
-	VALUE_PA0B2,
-	VALUE_PA1B0,
-	VALUE_PA1B1,
-	VALUE_PA1B2,
-	VALUE_WL0GPIO0,
-	VALUE_WL0GPIO1,
-	VALUE_WL0GPIO2,
-	VALUE_WL0GPIO3,
-	VALUE_MAXPA,
-	VALUE_MAXPBG,
-	VALUE_ITSSIA,
-	VALUE_ITSSIBG,
-	VALUE_SVER,
- VALUE_LAST = VALUE_SVER,
-};
-
-struct cmdline_vparm {
-	enum valuetype type;
-	int set;
-	int bits;
-	union {
-		uint16_t value;
-		uint8_t mac[6];
-		struct {
-			uint8_t value;
-			uint8_t offset;
-		} raw;
-	} u;
-};
-
-struct cmdline_args {
-	const char *infile;
-	const char *outfile;
-	int verbose;
-	int force;
-	int bin_mode;
-
-#define MAX_VPARM	512
-	struct cmdline_vparm vparm[MAX_VPARM];
-	int nr_vparm;
-};
-extern struct cmdline_args cmdargs;
-
-#endif /* BCM43xx_SPROMTOOL_H_ */

Copied: trunk/sprom/ssb_sprom.c (from rev 1220, trunk/sprom/bcm43xx_sprom.c)
===================================================================
--- trunk/sprom/bcm43xx_sprom.c	2007-02-17 20:56:53 UTC (rev 1220)
+++ trunk/sprom/ssb_sprom.c	2007-02-17 21:05:03 UTC (rev 1221)
@@ -0,0 +1,1420 @@
+/*
+
+  Broadcom Sonics Silicon Backplane bus SPROM data modification tool
+
+  Copyright (c) 2006-2007 Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-svn">mb at bu3sch.de</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; see the file COPYING.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+
+*/
+
+#include &quot;ssb_sprom.h&quot;
+#include &quot;utils.h&quot;
+
+#include &lt;unistd.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;sys/stat.h&gt;
+
+
+struct cmdline_args cmdargs;
+
+static int value_length_map[] = { /* value to number of bits */
+	[VALUE_RAW] = 8,
+	[VALUE_SUBP] = 16,
+	[VALUE_SUBV] = 16,
+	[VALUE_PPID] = 16,
+	[VALUE_BFLHI] = 16,
+	[VALUE_BFL] = 16,
+	[VALUE_BGMAC] = -1,
+	[VALUE_ETMAC] = -1,
+	[VALUE_AMAC] = -1,
+	[VALUE_ET0PHY] = 8,
+	[VALUE_ET1PHY] = 8,
+	[VALUE_ET0MDC] = 1,
+	[VALUE_ET1MDC] = 1,
+	[VALUE_BREV] = 8,
+	[VALUE_LOC] = 4,
+	[VALUE_ANTA0] = 1,
+	[VALUE_ANTA1] = 1,
+	[VALUE_ANTBG0] = 1,
+	[VALUE_ANTBG1] = 1,
+	[VALUE_ANTGA] = 8,
+	[VALUE_ANTGBG] = 8,
+	[VALUE_PA0B0] = 16,
+	[VALUE_PA0B1] = 16,
+	[VALUE_PA0B2] = 16,
+	[VALUE_PA1B0] = 16,
+	[VALUE_PA1B1] = 16,
+	[VALUE_PA1B2] = 16,
+	[VALUE_WL0GPIO0] = 8,
+	[VALUE_WL0GPIO1] = 8,
+	[VALUE_WL0GPIO2] = 8,
+	[VALUE_WL0GPIO3] = 8,
+	[VALUE_MAXPA] = 8,
+	[VALUE_MAXPBG] = 8,
+	[VALUE_ITSSIA] = 8,
+	[VALUE_ITSSIBG] = 8,
+	[VALUE_SVER] = 8,
+};
+
+
+static int hexdump_sprom(const uint8_t *sprom, char *buffer, size_t bsize)
+{
+	int i, pos = 0;
+
+	for (i = 0; i &lt; SPROM_SIZE; i++) {
+		pos += snprintf(buffer + pos, bsize - pos - 1,
+				&quot;%02X&quot;, sprom[i] &amp; 0xFF);
+	}
+
+	return pos + 1;
+}
+
+static uint8_t sprom_crc(const uint8_t *sprom)
+{
+	int i;
+	uint8_t crc = 0xFF;
+
+	for (i = 0; i &lt; SPROM_SIZE - 1; i++)
+		crc = crc8(crc, sprom[i]);
+	crc ^= 0xFF;
+
+	return crc;
+}
+
+static int write_output_binary(int fd, const uint8_t *sprom)
+{
+	ssize_t w;
+
+	w = write(fd, sprom, SPROM_SIZE);
+	if (w &lt; 0)
+		return -1;
+
+	return 0;
+}
+
+static int write_output_hex(int fd, const uint8_t *sprom)
+{
+	ssize_t w;
+	char tmp[SPROM_SIZE * 2 + 10] = { 0 };
+
+	hexdump_sprom(sprom, tmp, sizeof(tmp));
+	prinfo(&quot;Raw output:  %s\n&quot;, tmp);
+	w = write(fd, tmp, SPROM_SIZE * 2);
+	if (w &lt; 0)
+		return -1;
+
+	return 0;
+}
+
+static int write_output(int fd, const uint8_t *sprom)
+{
+	int err;
+
+	if (cmdargs.outfile) {
+		err = ftruncate(fd, 0);
+		if (err) {
+			prerror(&quot;Could not truncate --outfile %s\n&quot;,
+				cmdargs.outfile);
+			return -1;
+		}
+	}
+
+	if (cmdargs.bin_mode)
+		err = write_output_binary(fd, sprom);
+	else
+		err = write_output_hex(fd, sprom);
+	if (err)
+		prerror(&quot;Could not write output data.\n&quot;);
+
+	return err;
+}
+
+static int modify_value(uint8_t *sprom,
+			struct cmdline_vparm *vparm)
+{
+	const uint16_t v = vparm-&gt;u.value;
+	uint16_t tmp = 0;
+
+	switch (vparm-&gt;type) {
+	case VALUE_RAW:
+		sprom[vparm-&gt;u.raw.offset] = vparm-&gt;u.raw.value;
+		break;
+	case VALUE_SUBP:
+		sprom[SPROM_SUBP + 0] = (v &amp; 0x00FF);
+		sprom[SPROM_SUBP + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
+		break;
+	case VALUE_SUBV:
+		sprom[SPROM_SUBV + 0] = (v &amp; 0x00FF);
+		sprom[SPROM_SUBV + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
+		break;
+	case VALUE_PPID:
+		sprom[SPROM_PPID + 0] = (v &amp; 0x00FF);
+		sprom[SPROM_PPID + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
+		break;
+	case VALUE_BFLHI:
+		sprom[SPROM_BFLHI + 0] = (v &amp; 0x00FF);
+		sprom[SPROM_BFLHI + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
+		break;
+	case VALUE_BFL:
+		sprom[SPROM_BOARDFLAGS + 0] = (v &amp; 0x00FF);
+		sprom[SPROM_BOARDFLAGS + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
+		break;
+	case VALUE_BGMAC:
+		sprom[SPROM_IL0MACADDR + 1] = vparm-&gt;u.mac[0];
+		sprom[SPROM_IL0MACADDR + 0] = vparm-&gt;u.mac[1];
+		sprom[SPROM_IL0MACADDR + 3] = vparm-&gt;u.mac[2];
+		sprom[SPROM_IL0MACADDR + 2] = vparm-&gt;u.mac[3];
+		sprom[SPROM_IL0MACADDR + 5] = vparm-&gt;u.mac[4];
+		sprom[SPROM_IL0MACADDR + 4] = vparm-&gt;u.mac[5];
+		break;
+	case VALUE_ETMAC:
+		sprom[SPROM_ET0MACADDR + 1] = vparm-&gt;u.mac[0];
+		sprom[SPROM_ET0MACADDR + 0] = vparm-&gt;u.mac[1];
+		sprom[SPROM_ET0MACADDR + 3] = vparm-&gt;u.mac[2];
+		sprom[SPROM_ET0MACADDR + 2] = vparm-&gt;u.mac[3];
+		sprom[SPROM_ET0MACADDR + 5] = vparm-&gt;u.mac[4];
+		sprom[SPROM_ET0MACADDR + 4] = vparm-&gt;u.mac[5];
+		break;
+	case VALUE_AMAC:
+		sprom[SPROM_ET1MACADDR + 1] = vparm-&gt;u.mac[0];
+		sprom[SPROM_ET1MACADDR + 0] = vparm-&gt;u.mac[1];
+		sprom[SPROM_ET1MACADDR + 3] = vparm-&gt;u.mac[2];
+		sprom[SPROM_ET1MACADDR + 2] = vparm-&gt;u.mac[3];
+		sprom[SPROM_ET1MACADDR + 5] = vparm-&gt;u.mac[4];
+		sprom[SPROM_ET1MACADDR + 4] = vparm-&gt;u.mac[5];
+		break;
+	case VALUE_ET0PHY:
+		tmp |= sprom[SPROM_ETHPHY + 0];
+		tmp |= sprom[SPROM_ETHPHY + 1] &lt;&lt; 8;
+		tmp = ((tmp &amp; 0x001F) | (v &amp; 0x1F));
+		sprom[SPROM_ETHPHY + 0] = (tmp &amp; 0x00FF);
+		sprom[SPROM_ETHPHY + 1] = (tmp &amp; 0xFF00) &gt;&gt; 8;
+		break;
+	case VALUE_ET1PHY:
+		tmp |= sprom[SPROM_ETHPHY + 0];
+		tmp |= sprom[SPROM_ETHPHY + 1] &lt;&lt; 8;
+		tmp = ((tmp &amp; 0x03E0) | ((v &amp; 0x1F) &lt;&lt; 5));
+		sprom[SPROM_ETHPHY + 0] = (tmp &amp; 0x00FF);
+		sprom[SPROM_ETHPHY + 1] = (tmp &amp; 0xFF00) &gt;&gt; 8;
+		break;
+	case VALUE_ET0MDC:
+		sprom[SPROM_ETHPHY + 1] &amp;= ~(1 &lt;&lt; 6);
+		if (v)
+			sprom[SPROM_ETHPHY + 1] |= (1 &lt;&lt; 6);
+		break;
+	case VALUE_ET1MDC:
+		sprom[SPROM_ETHPHY + 1] &amp;= ~(1 &lt;&lt; 7);
+		if (v)
+			sprom[SPROM_ETHPHY + 1] |= (1 &lt;&lt; 7);
+		break;
+	case VALUE_BREV:
+		sprom[SPROM_BOARDREV + 0] = v;
+		break;
+	case VALUE_LOC:
+		tmp = (sprom[SPROM_BOARDREV + 1] &amp; 0xF0);
+		tmp |= (v &amp; 0x0F);
+		sprom[SPROM_BOARDREV + 1] = (tmp &amp; 0xFF);
+		break;
+	case VALUE_ANTA0:
+		sprom[SPROM_BOARDREV + 1] &amp;= ~(1 &lt;&lt; 4);
+		if (v)
+			sprom[SPROM_BOARDREV + 1] |= (1 &lt;&lt; 4);
+		break;
+	case VALUE_ANTA1:
+		sprom[SPROM_BOARDREV + 1] &amp;= ~(1 &lt;&lt; 5);
+		if (v)
+			sprom[SPROM_BOARDREV + 1] |= (1 &lt;&lt; 5);
+		break;
+	case VALUE_ANTBG0:
+		sprom[SPROM_BOARDREV + 1] &amp;= ~(1 &lt;&lt; 6);
+		if (v)
+			sprom[SPROM_BOARDREV + 1] |= (1 &lt;&lt; 6);
+		break;
+	case VALUE_ANTBG1:
+		sprom[SPROM_BOARDREV + 1] &amp;= ~(1 &lt;&lt; 7);
+		if (v)
+			sprom[SPROM_BOARDREV + 1] |= (1 &lt;&lt; 7);
+		break;
+	case VALUE_ANTGA:
+		sprom[SPROM_ANTENNA_GAIN + 0] = (v &amp; 0xFF);
+		break;
+	case VALUE_ANTGBG:
+		sprom[SPROM_ANTENNA_GAIN + 1] = (v &amp; 0xFF);
+		break;
+	case VALUE_PA0B0:
+		sprom[SPROM_PA0B0 + 0] = (v &amp; 0x00FF);
+		sprom[SPROM_PA0B0 + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
+		break;
+	case VALUE_PA0B1:
+		sprom[SPROM_PA0B1 + 0] = (v &amp; 0x00FF);
+		sprom[SPROM_PA0B1 + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
+		break;
+	case VALUE_PA0B2:
+		sprom[SPROM_PA0B2 + 0] = (v &amp; 0x00FF);
+		sprom[SPROM_PA0B2 + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
+		break;
+	case VALUE_PA1B0:
+		sprom[SPROM_PA1B0 + 0] = (v &amp; 0x00FF);
+		sprom[SPROM_PA1B0 + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
+		break;
+	case VALUE_PA1B1:
+		sprom[SPROM_PA1B1 + 0] = (v &amp; 0x00FF);
+		sprom[SPROM_PA1B1 + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
+		break;
+	case VALUE_PA1B2:
+		sprom[SPROM_PA1B2 + 0] = (v &amp; 0x00FF);
+		sprom[SPROM_PA1B2 + 1] = (v &amp; 0xFF00) &gt;&gt; 8;
+		break;
+	case VALUE_WL0GPIO0:
+		sprom[SPROM_WL0GPIO0 + 0] = (v &amp; 0xFF);
+		break;
+	case VALUE_WL0GPIO1:
+		sprom[SPROM_WL0GPIO0 + 1] = (v &amp; 0xFF);
+		break;
+	case VALUE_WL0GPIO2:
+		sprom[SPROM_WL0GPIO2 + 0] = (v &amp; 0xFF);
+		break;
+	case VALUE_WL0GPIO3:
+		sprom[SPROM_WL0GPIO2 + 1] = (v &amp; 0xFF);
+		break;
+	case VALUE_MAXPA:
+		sprom[SPROM_MAXPWR + 0] = (v &amp; 0xFF);
+		break;
+	case VALUE_MAXPBG:
+		sprom[SPROM_MAXPWR + 1] = (v &amp; 0xFF);
+		break;
+	case VALUE_ITSSIA:
+		sprom[SPROM_IDL_TSSI_TGT + 0] = (v &amp; 0xFF);
+		break;
+	case VALUE_ITSSIBG:
+		sprom[SPROM_IDL_TSSI_TGT + 1] = (v &amp; 0xFF);
+		break;
+	case VALUE_SVER:
+		sprom[SPROM_VERSION + 0] = (v &amp; 0xFF);
+		break;
+	default:
+		prerror(&quot;vparm-&gt;type internal error (0)\n&quot;);
+		exit(1);
+	}
+
+	return 0;
+}
+
+static int modify_sprom(uint8_t *sprom)
+{
+	struct cmdline_vparm *vparm;
+	int i;
+	int modified = 0;
+	uint8_t crc;
+
+	for (i = 0; i &lt; cmdargs.nr_vparm; i++) {
+		vparm = &amp;(cmdargs.vparm[i]);
+		if (!vparm-&gt;set)
+			continue;
+		modify_value(sprom, vparm);
+		modified = 1;
+	}
+	if (modified) {
+		/* Recalculate the CRC. */
+		crc = sprom_crc(sprom);
+		sprom[SPROM_VERSION + 1] = crc;
+	}
+
+	return modified;
+}
+
+static void display_value(const uint8_t *sprom,
+			  struct cmdline_vparm *vparm)
+{
+	const char *desc;
+	uint8_t offset;
+	uint16_t value;
+	uint16_t tmp;
+
+	switch (vparm-&gt;type) {
+	case VALUE_RAW:
+		desc = &quot;RAW&quot;;
+		offset = vparm-&gt;u.raw.offset;
+		value = sprom[offset];
+		break;
+	case VALUE_SUBP:
+		desc = &quot;Subsytem product ID&quot;;
+		offset = SPROM_SUBP;
+		value = sprom[SPROM_SUBP + 0];
+		value |= sprom[SPROM_SUBP + 1] &lt;&lt; 8;
+		break;
+	case VALUE_SUBV:
+		desc = &quot;Subsystem vendor ID&quot;;
+		offset = SPROM_SUBV;
+		value = sprom[SPROM_SUBV + 0];
+		value |= sprom[SPROM_SUBV + 1] &lt;&lt; 8;
+		break;
+	case VALUE_PPID:
+		desc = &quot;PCI Product ID&quot;;
+		offset = SPROM_PPID;
+		value = sprom[SPROM_PPID + 0];
+		value |= sprom[SPROM_PPID + 1] &lt;&lt; 8;
+		break;
+	case VALUE_BFLHI:
+		desc = &quot;High 16 bits of Boardflags&quot;;
+		offset = SPROM_BFLHI;
+		value = sprom[SPROM_BFLHI + 0];
+		value |= sprom[SPROM_BFLHI + 1] &lt;&lt; 8;
+		break;
+	case VALUE_BFL:
+		desc = &quot;Low 16 bits of Boardflags&quot;;
+		offset = SPROM_BOARDFLAGS;
+		value = sprom[SPROM_BOARDFLAGS + 0];
+		value |= sprom[SPROM_BOARDFLAGS + 1] &lt;&lt; 8;
+		break;
+	case VALUE_BGMAC:
+		desc = &quot;MAC address for 802.11b/g&quot;;
+		offset = SPROM_IL0MACADDR;
+		value = 0;
+		break;
+	case VALUE_ETMAC:
+		desc = &quot;MAC address for ethernet&quot;;
+		offset = SPROM_ET0MACADDR;
+		value = 0;
+		break;
+	case VALUE_AMAC:
+		desc = &quot;MAC address for 802.11a&quot;;
+		offset = SPROM_ET1MACADDR;
+		value = 0;
+		break;
+	case VALUE_ET0PHY:
+		desc = &quot;Ethernet phy settings (0)&quot;;
+		offset = SPROM_ETHPHY;
+		tmp = sprom[SPROM_ETHPHY + 0];
+		tmp |= sprom[SPROM_ETHPHY + 1] &lt;&lt; 8;
+		value = (tmp &amp; 0x001F);
+		break;
+	case VALUE_ET1PHY:
+		desc = &quot;Ethernet phy settings (1)&quot;;
+		offset = SPROM_ETHPHY;
+		tmp = sprom[SPROM_ETHPHY + 0];
+		tmp |= sprom[SPROM_ETHPHY + 1] &lt;&lt; 8;
+		value = (tmp &amp; 0x03E0) &gt;&gt; 5;
+		break;
+	case VALUE_ET0MDC:
+		desc = &quot;et0mdcport&quot;;
+		offset = SPROM_ETHPHY + 1;
+		value = 0;
+		if (sprom[SPROM_ETHPHY + 1] &amp; (1 &lt;&lt; 6))
+			value = 1;
+		break;
+	case VALUE_ET1MDC:
+		desc = &quot;et1mdcport&quot;;
+		offset = SPROM_ETHPHY + 1;
+		value = 0;
+		if (sprom[SPROM_ETHPHY + 1] &amp; (1 &lt;&lt; 7))
+			value = 1;
+		break;
+	case VALUE_BREV:
+		desc = &quot;Board revision&quot;;
+		offset = SPROM_BOARDREV;
+		value = sprom[SPROM_BOARDREV + 0];
+		break;
+	case VALUE_LOC:
+		desc = &quot;Locale / Country Code&quot;;
+		offset = SPROM_BOARDREV + 1;
+		value = (sprom[SPROM_BOARDREV + 1] &amp; 0x0F);
+		break;
+	case VALUE_ANTA0:
+		desc = &quot;A PHY antenna 0 available&quot;;
+		offset = SPROM_BOARDREV + 1;
+		value = 0;
+		if (sprom[SPROM_BOARDREV + 1] &amp; (1 &lt;&lt; 4))
+			value = 1;
+		break;
+	case VALUE_ANTA1:
+		desc = &quot;A PHY antenna 1 available&quot;;
+		offset = SPROM_BOARDREV + 1;
+		value = 0;
+		if (sprom[SPROM_BOARDREV + 1] &amp; (1 &lt;&lt; 5))
+			value = 1;
+		break;
+	case VALUE_ANTBG0:
+		desc = &quot;B/G PHY antenna 1 available&quot;;
+		offset = SPROM_BOARDREV + 1;
+		value = 0;
+		if (sprom[SPROM_BOARDREV + 1] &amp; (1 &lt;&lt; 6))
+			value = 1;
+		break;
+	case VALUE_ANTBG1:
+		desc = &quot;B/G PHY antenna 1 available&quot;;
+		offset = SPROM_BOARDREV + 1;
+		value = 0;
+		if (sprom[SPROM_BOARDREV + 1] &amp; (1 &lt;&lt; 7))
+			value = 1;
+		break;
+	case VALUE_ANTGA:
+		desc = &quot;A PHY antenna gain&quot;;
+		offset = SPROM_ANTENNA_GAIN;
+		value = sprom[SPROM_ANTENNA_GAIN];
+		break;
+	case VALUE_ANTGBG:
+		desc = &quot;A PHY antenna gain&quot;;
+		offset = SPROM_ANTENNA_GAIN + 1;
+		value = sprom[SPROM_ANTENNA_GAIN + 1];
+		break;
+	case VALUE_PA0B0:
+		desc = &quot;pa0b0&quot;;
+		offset = SPROM_PA0B0;
+		value = sprom[offset + 0];
+		value |= sprom[offset + 1] &lt;&lt; 8;
+		break;
+	case VALUE_PA0B1:
+		desc = &quot;pa0b1&quot;;
+		offset = SPROM_PA0B1;
+		value = sprom[offset + 0];
+		value |= sprom[offset + 1] &lt;&lt; 8;
+		break;
+	case VALUE_PA0B2:
+		desc = &quot;pa0b2&quot;;
+		offset = SPROM_PA0B2;
+		value = sprom[offset + 0];
+		value |= sprom[offset + 1] &lt;&lt; 8;
+		break;
+	case VALUE_PA1B0:
+		desc = &quot;pa1b0&quot;;
+		offset = SPROM_PA1B0;
+		value = sprom[offset + 0];
+		value |= sprom[offset + 1] &lt;&lt; 8;
+		break;
+	case VALUE_PA1B1:
+		desc = &quot;pa1b1&quot;;
+		offset = SPROM_PA1B1;
+		value = sprom[offset + 0];
+		value |= sprom[offset + 1] &lt;&lt; 8;
+		break;
+	case VALUE_PA1B2:
+		desc = &quot;pa1b2&quot;;
+		offset = SPROM_PA1B2;
+		value = sprom[offset + 0];
+		value |= sprom[offset + 1] &lt;&lt; 8;
+		break;
+	case VALUE_WL0GPIO0:
+		desc = &quot;LED 0 behaviour&quot;;
+		offset = SPROM_WL0GPIO0 + 0;
+		value = sprom[offset];
+		break;
+	case VALUE_WL0GPIO1:
+		desc = &quot;LED 1 behaviour&quot;;
+		offset = SPROM_WL0GPIO0 + 1;
+		value = sprom[offset];
+		break;
+	case VALUE_WL0GPIO2:
+		desc = &quot;LED 2 behaviour&quot;;
+		offset = SPROM_WL0GPIO2 + 0;
+		value = sprom[offset];
+		break;
+	case VALUE_WL0GPIO3:
+		desc = &quot;LED 3 behaviour&quot;;
+		offset = SPROM_WL0GPIO2 + 1;
+		value = sprom[offset];
+		break;
+	case VALUE_MAXPA:
+		desc = &quot;A PHY max powerout&quot;;
+		offset = SPROM_MAXPWR + 0;
+		value = sprom[offset];
+		break;
+	case VALUE_MAXPBG:
+		desc = &quot;B/G PHY max powerout&quot;;
+		offset = SPROM_MAXPWR + 1;
+		value = sprom[offset];
+		break;
+	case VALUE_ITSSIA:
+		desc = &quot;A PHY idle TSSI target&quot;;
+		offset = SPROM_IDL_TSSI_TGT + 0;
+		value = sprom[offset];
+		break;
+	case VALUE_ITSSIBG:
+		desc = &quot;B/G PHY idle TSSI target&quot;;
+		offset = SPROM_IDL_TSSI_TGT + 1;
+		value = sprom[offset];
+		break;
+	case VALUE_SVER:
+		desc = &quot;SPROM version&quot;;
+		offset = SPROM_VERSION;
+		value = sprom[offset];
+		break;
+	default:
+		prerror(&quot;vparm-&gt;type internal error (1)\n&quot;);
+		exit(1);
+	}
+
+	switch (vparm-&gt;bits) {
+	case 1:
+		prdata(&quot;SPROM(0x%02X, %s) = %s\n&quot;,
+		       offset, desc, value ? &quot;ON&quot; : &quot;OFF&quot;);
+		break;
+	case 4:
+		prdata(&quot;SPROM(0x%02X, %s) = 0x%01X\n&quot;,
+		       offset, desc, (value &amp; 0xF));
+		break;
+	case 8:
+		prdata(&quot;SPROM(0x%02X, %s) = 0x%02X\n&quot;,
+		       offset, desc, (value &amp; 0xFF));
+		break;
+	case 16:
+		prdata(&quot;SPROM(0x%02X, %s) = 0x%04X\n&quot;,
+		       offset, desc, (value &amp; 0xFFFF));
+		break;
+	case -1: {
+		/* MAC address. */
+		const uint8_t *p = &amp;(sprom[offset]);
+
+		prdata(&quot;SPROM(0x%02X, %s) = %02x:%02x:%02x:%02x:%02x:%02x\n&quot;,
+		       offset, desc,
+		       p[1], p[0], p[3], p[2], p[5], p[4]);
+		break;
+	}
+	default:
+		prerror(&quot;vparm-&gt;bits internal error (%d)\n&quot;,
+			vparm-&gt;bits);
+		exit(1);
+	}
+}
+
+static int display_sprom(const uint8_t *sprom)
+{
+	struct cmdline_vparm *vparm;
+	int i;
+
+	for (i = 0; i &lt; cmdargs.nr_vparm; i++) {
+		vparm = &amp;(cmdargs.vparm[i]);
+		if (vparm-&gt;set)
+			continue;
+		display_value(sprom, vparm);
+	}
+
+	return 0;
+}
+
+static int validate_input(const uint8_t *sprom)
+{
+	uint8_t crc, expected_crc;
+
+	crc = sprom_crc(sprom);
+	expected_crc = sprom[SPROM_VERSION + 1];
+	if (crc != expected_crc) {
+		prerror(&quot;Corrupt input data (crc: 0x%02X, expected: 0x%02X)\n&quot;,
+			crc, expected_crc);
+		if (!cmdargs.force)
+			return 1;
+	}
+
+	return 0;
+}
+
+static int parse_input(uint8_t *sprom, char *buffer, size_t bsize)
+{
+	char *input;
+	size_t inlen;
+	size_t cnt;
+	unsigned long parsed;
+	char tmp[SPROM_SIZE * 2 + 10] = { 0 };
+
+	if (cmdargs.bin_mode) {
+		/* The input buffer already contains
+		 * the binary sprom data.
+		 */
+		internal_error_on(bsize != SPROM_SIZE);
+		memcpy(sprom, buffer, SPROM_SIZE);
+		return 0;
+	}
+
+	inlen = bsize;
+	input = strchr(buffer, ':');
+	if (input) {
+		input++;
+		inlen -= input - buffer;
+	} else
+		input = buffer;
+
+	if (inlen &lt; SPROM_SIZE * 2) {
+		prerror(&quot;Input data too short\n&quot;);
+		return -1;
+	}
+	for (cnt = 0; cnt &lt; SPROM_SIZE; cnt++) {
+		memcpy(tmp, input + cnt * 2, 2);
+		parsed = strtoul(tmp, NULL, 16);
+		sprom[cnt] = parsed &amp; 0xFF;
+	}
+
+	if (cmdargs.verbose) {
+		hexdump_sprom(sprom, tmp, sizeof(tmp));
+		prinfo(&quot;Raw input:  %s\n&quot;, tmp);
+	}
+
+	return 0;
+}
+
+static int read_infile(int fd, char **buffer, size_t *bsize)
+{
+	struct stat s;
+	int err;
+	ssize_t r;
+
+	err = fstat(fd, &amp;s);
+	if (err) {
+		prerror(&quot;Could not stat input file.\n&quot;);
+		return err;
+	}
+	if (s.st_size == 0) {
+		prerror(&quot;No input data\n&quot;);
+		return -1;
+	}
+	if (cmdargs.bin_mode) {
+		if (s.st_size != SPROM_SIZE) {
+			prerror(&quot;The input data is no SPROM Binary data. &quot;
+				&quot;The size must be exactly %d bytes, &quot;
+				&quot;but it is %u bytes\n&quot;,
+				SPROM_SIZE, (unsigned int)(s.st_size));
+			return -1;
+		}
+	} else {
+		if (s.st_size &gt; 1024 * 1024) {
+			prerror(&quot;The input data does not look &quot;
+				&quot;like SPROM HEX data (too long).\n&quot;);
+			return -1;
+		}
+	}
+
+	*bsize = s.st_size;
+	if (!cmdargs.bin_mode)
+		(*bsize)++;
+	*buffer = malloce(*bsize);
+	r = read(fd, *buffer, s.st_size);
+	if (r != s.st_size) {
+		prerror(&quot;Could not read input data.\n&quot;);
+		return -1;
+	}
+	if (!cmdargs.bin_mode)
+		(*buffer)[r] = '\0';
+
+	return 0;
+}
+
+static void close_infile(int fd)
+{
+	if (cmdargs.infile)
+		close(fd);
+}
+
+static void close_outfile(int fd)
+{
+	if (cmdargs.outfile)
+		close(fd);
+}
+
+static int open_infile(int *fd)
+{
+	*fd = STDIN_FILENO;
+	if (!cmdargs.infile)
+		return 0;
+	*fd = open(cmdargs.infile, O_RDONLY);
+	if (*fd &lt; 0) {
+		prerror(&quot;Could not open --infile %s\n&quot;,
+			cmdargs.infile);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int open_outfile(int *fd)
+{
+	*fd = STDOUT_FILENO;
+	if (!cmdargs.outfile)
+		return 0;
+	*fd = open(cmdargs.outfile, O_RDWR | O_CREAT, 0644);
+	if (*fd &lt; 0) {
+		prerror(&quot;Could not open --outfile %s\n&quot;,
+			cmdargs.outfile);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void print_banner(int forceprint)
+{
+	const char *str = &quot;Broadcom-SSB SPROM data modification tool version &quot; VERSION &quot;\n&quot;;
+	if (forceprint)
+		prdata(str);
+	else
+		prinfo(str);
+}
+
+static void print_usage(int argc, char *argv[])
+{
+	print_banner(1);
+	prdata(&quot;\nUsage: %s [OPTION]\n&quot;, argv[0]);
+	prdata(&quot;  -i|--input FILE       Input file\n&quot;);
+	prdata(&quot;  -o|--output FILE      Output file\n&quot;);
+	prdata(&quot;  -b|--binmode          The Input data is plain binary data and Output will be binary\n&quot;);
+	prdata(&quot;  -V|--verbose          Be verbose\n&quot;);
+	prdata(&quot;  -f|--force            Override error checks\n&quot;);
+	prdata(&quot;  -v|--version          Print version\n&quot;);
+	prdata(&quot;  -h|--help             Print this help\n&quot;);
+	prdata(&quot;\n&quot;);
+	prdata(&quot;Value Parameters:\n&quot;);
+	prdata(&quot;\n&quot;);
+	prdata(&quot;  -s|--rawset OFF,VAL   Set a VALue at a byte-OFFset\n&quot;);
+	prdata(&quot;  -g|--rawget OFF       Get a value at a byte-OFFset\n&quot;);
+	prdata(&quot;\n&quot;);
+	prdata(&quot;Predefined values (for displaying (GET) or modification):\n&quot;);
+	prdata(&quot;  --subp [0xFFFF]       Subsytem product ID for PCI\n&quot;);
+	prdata(&quot;  --subv [0xFFFF]       Subsystem vendor ID for PCI\n&quot;);
+	prdata(&quot;  --ppid [0xFFFF]       Product ID for PCI\n&quot;);
+	prdata(&quot;  --bflhi [0xFFFF]      High 16 bits of boardflags (only if spromversion &gt; 1)\n&quot;);
+	prdata(&quot;  --bfl [0xFFFF]        Low 16 bits of boardflags\n&quot;);
+	prdata(&quot;  --bgmac [MAC-ADDR]    MAC address for 802.11b/g\n&quot;);
+	prdata(&quot;  --etmac [MAC-ADDR]    MAC address for ethernet, see b44 driver\n&quot;);
+	prdata(&quot;  --amac [MAC-ADDR]     Mac address for 802.11a\n&quot;);
+	prdata(&quot;  --et0phy [0xFF]\n&quot;);
+	prdata(&quot;  --et1phy [0xFF]\n&quot;);
+	prdata(&quot;  --et0mdc [BOOL]\n&quot;);
+	prdata(&quot;  --et1mdc [BOOL]\n&quot;);
+	prdata(&quot;  --brev [0xFF]         Board revision\n&quot;);
+	prdata(&quot;  --loc [0xF]           Country code\n&quot;);
+	prdata(&quot;  --anta0 [BOOL]        Antenna 0 available for A PHY\n&quot;);
+	prdata(&quot;  --anta1 [BOOL]        Antenna 1 available for A PHY\n&quot;);
+	prdata(&quot;  --antbg0 [BOOL]       Antenna 0 available for B/G PHY\n&quot;);
+	prdata(&quot;  --antbg1 [BOOL]       Antenna 1 available for B/G PHY\n&quot;);
+	prdata(&quot;  --antga [0xFF]        Antenna gain for A PHY\n&quot;);
+	prdata(&quot;  --antgbg [0xFF]       Antenna gain for B/G PHY\n&quot;);
+	prdata(&quot;  --pa0b0 [0xFFFF]\n&quot;);
+	prdata(&quot;  --pa0b1 [0xFFFF]\n&quot;);
+	prdata(&quot;  --pa0b2 [0xFFFF]\n&quot;);
+	prdata(&quot;  --pa1b0 [0xFFFF]\n&quot;);
+	prdata(&quot;  --pa1b1 [0xFFFF]\n&quot;);
+	prdata(&quot;  --pa1b2 [0xFFFF]\n&quot;);
+	prdata(&quot;  --wl0gpio0 [0xFF]     LED 0 behaviour\n&quot;);
+	prdata(&quot;  --wl0gpio1 [0xFF]     LED 1 behaviour\n&quot;);
+	prdata(&quot;  --wl0gpio2 [0xFF]     LED 2 behaviour\n&quot;);
+	prdata(&quot;  --wl0gpio3 [0xFF]     LED 3 behaviour\n&quot;);
+	prdata(&quot;  --maxpa [0xFF]        A PHY max power\n&quot;);
+	prdata(&quot;  --maxpbg [0xFF]       B/G PHY max power\n&quot;);
+	prdata(&quot;  --itssia [0xFF]       Idle tssi target for A PHY\n&quot;);
+	prdata(&quot;  --itssibg [0xFF]      Idle tssi target for B/G PHY\n&quot;);
+	prdata(&quot;  --sver [0xFF]         SPROM-version\n&quot;);
+	prdata(&quot;\n&quot;);
+	prdata(&quot;  -P|--print-all        Display all values\n&quot;);
+	prdata(&quot;\n&quot;);
+	prdata(&quot; BOOL      is a boolean value. Either 0 or 1\n&quot;);
+	prdata(&quot; 0xF..     is a hexadecimal value\n&quot;);
+	prdata(&quot; MAC-ADDR  is a MAC address in the format 00:00:00:00:00:00\n&quot;);
+	prdata(&quot; If the value parameter is \&quot;GET\&quot;, the value will be printed;\n&quot;);
+	prdata(&quot; otherwise it is modified.\n&quot;);
+}
+
+#define ARG_MATCH		0
+#define ARG_NOMATCH		1
+#define ARG_ERROR		-1
+
+static int do_cmp_arg(char **argv, int *pos,
+		      const char *template,
+		      int allow_merged,
+		      char **param)
+{
+	char *arg;
+	char *next_arg;
+	size_t arg_len, template_len;
+
+	arg = argv[*pos];
+	next_arg = argv[*pos + 1];
+	arg_len = strlen(arg);
+	template_len = strlen(template);
+
+	if (param) {
+		/* Maybe we have a merged parameter here.
+		 * A merged parameter is &quot;-pfoobar&quot; for example.
+		 */
+		if (allow_merged &amp;&amp; arg_len &gt; template_len) {
+			if (memcmp(arg, template, template_len) == 0) {
+				*param = arg + template_len;
+				return ARG_MATCH;
+			}
+			return ARG_NOMATCH;
+		} else if (arg_len != template_len)
+			return ARG_NOMATCH;
+		*param = next_arg;
+	}
+	if (strcmp(arg, template) == 0) {
+		if (param) {
+			/* Skip the parameter on the next iteration. */
+			(*pos)++;
+			if (*param == 0) {
+				prerror(&quot;%s needs a parameter\n&quot;, arg);
+				return ARG_ERROR;
+			}
+		}
+		return ARG_MATCH;
+	}
+
+	return ARG_NOMATCH;
+}
+
+/* Simple and lean command line argument parsing. */
+static int cmp_arg(char **argv, int *pos,
+		   const char *long_template,
+		   const char *short_template,
+		   char **param)
+{
+	int err;
+
+	if (long_template) {
+		err = do_cmp_arg(argv, pos, long_template, 0, param);
+		if (err == ARG_MATCH || err == ARG_ERROR)
+			return err;
+	}
+	err = ARG_NOMATCH;
+	if (short_template)
+		err = do_cmp_arg(argv, pos, short_template, 1, param);
+	return err;
+}
+
+static int parse_err;
+
+static int arg_match(char **argv, int *i,
+		     const char *long_template,
+		     const char *short_template,
+		     char **param)
+{
+	int res;
+
+	res = cmp_arg(argv, i, long_template,
+		      short_template, param);
+	if (res == ARG_ERROR) {
+		parse_err = 1;
+		return 0;
+	}
+	return (res == ARG_MATCH);
+}
+
+static int parse_value(const char *str,
+		       struct cmdline_vparm *vparm,
+		       const char *param)
+{
+	unsigned long v;
+	int i;
+
+	vparm-&gt;bits = value_length_map[vparm-&gt;type];
+	vparm-&gt;set = 1;
+	if (strcmp(str, &quot;GET&quot;) == 0 || strcmp(str, &quot;get&quot;) == 0) {
+		vparm-&gt;set = 0;
+		return 0;
+	}
+	if (vparm-&gt;bits == 1) {
+		/* This is a boolean value. */
+		if (strcmp(str, &quot;0&quot;) == 0)
+			vparm-&gt;u.value = 0;
+		else if (strcmp(str, &quot;1&quot;) == 0)
+			vparm-&gt;u.value = 1;
+		else
+			goto error_bool;
+		return 1;
+	}
+
+	if (strncmp(str, &quot;0x&quot;, 2) != 0)
+		goto error;
+	str += 2;
+	for (i = 0; i &lt; vparm-&gt;bits / 4; i++) {
+		if (str[i] == '\0')
+			goto error;
+	}
+	if (str[i] != '\0')
+		goto error;
+	errno = 0;
+	v = strtoul(str, NULL, 16);
+	if (errno)
+		goto error;
+	vparm-&gt;u.value = v;
+
+	return 1;
+error:
+	if (param) {
+		prerror(&quot;%s value parsing error. Format: 0x&quot;, param);
+		for (i = 0; i &lt; vparm-&gt;bits / 4; i++)
+			prerror(&quot;F&quot;);
+		prerror(&quot;\n&quot;);
+	}
+	return -1;
+
+error_bool:
+	if (param)
+		prerror(&quot;%s value parsing error. Format: 0 or 1 (boolean)\n&quot;, param);
+	return -1;
+}
+
+static int parse_mac(const char *str,
+		     struct cmdline_vparm *vparm,
+		     const char *param)
+{
+	int i;
+	char *delim;
+	const char *in = str;
+	uint8_t *out = vparm-&gt;u.mac;
+
+	vparm-&gt;bits = -1;
+	vparm-&gt;set = 1;
+	if (strcmp(str, &quot;GET&quot;) == 0 || strcmp(str, &quot;get&quot;) == 0) {
+		vparm-&gt;set = 0;
+		return 0;
+	}
+
+	for (i = 0; ; i++) {
+		errno = 0;
+		out[i] = strtoul(in, NULL, 16);
+		if (errno)
+			goto error;
+		if (i == 5) {
+			if (in[1] != '\0' &amp;&amp; in[2] != '\0')
+				goto error;
+			break;
+		}
+		delim = strchr(in, ':');
+		if (!delim)
+			goto error;
+		in = delim + 1;
+	}
+
+	return 1;
+error:
+	prerror(&quot;%s MAC parsing error. Format: 00:00:00:00:00:00\n&quot;, param);
+	return -1;
+}
+
+static int parse_rawset(const char *str,
+			struct cmdline_vparm *vparm)
+{
+	char *delim;
+	uint8_t value;
+	uint8_t offset;
+	int err;
+
+	vparm-&gt;type = VALUE_RAW;
+
+	delim = strchr(str, ',');
+	if (!delim)
+		goto error;
+	*delim = '\0';
+	err = parse_value(str, vparm, NULL);
+	if (err != 1)
+		goto error;
+	offset = vparm-&gt;u.value;
+	if (offset &gt;= SPROM_SIZE) {
+		prerror(&quot;--rawset offset too big (&gt;= 0x%02X)\n&quot;,
+			SPROM_SIZE);
+		return -1;
+	}
+	err = parse_value(delim + 1, vparm, NULL);
+	if (err != 1)
+		goto error;
+	value = vparm-&gt;u.value;
+
+	vparm-&gt;u.raw.value = value;
+	vparm-&gt;u.raw.offset = offset;
+	vparm-&gt;set = 1;
+
+	return 0;
+error:
+	prerror(&quot;--rawset value parsing error. Format: 0xFF,0xFF &quot;
+		&quot;(first Offset, second Value)\n&quot;);
+	return -1;
+}
+
+static int parse_rawget(const char *str,
+			struct cmdline_vparm *vparm)
+{
+	int err;
+	uint8_t offset;
+
+	vparm-&gt;type = VALUE_RAW;
+
+	err = parse_value(str, vparm, &quot;--rawget&quot;);
+	if (err != 1)
+		return -1;
+	offset = vparm-&gt;u.value;
+	if (offset &gt;= SPROM_SIZE) {
+		prerror(&quot;--rawget offset too big (&gt;= 0x%02X)\n&quot;,
+			SPROM_SIZE);
+		return -1;
+	}
+
+	vparm-&gt;u.raw.offset = offset;
+	vparm-&gt;type = VALUE_RAW;
+	vparm-&gt;set = 0;
+
+	return 0;
+}
+
+static int generate_printall(void)
+{
+	struct cmdline_vparm *vparm;
+	int count, i;
+	enum valuetype vt = VALUE_FIRST;
+
+	count = VALUE_LAST - VALUE_FIRST + 1;
+	for (i = 0; i &lt; count; i++, vt++) {
+		if (cmdargs.nr_vparm == MAX_VPARM) {
+			prerror(&quot;Too many value parameters.\n&quot;);
+			return -1;
+		}
+
+		vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+		vparm-&gt;type = vt;
+		vparm-&gt;set = 0;
+		vparm-&gt;bits = value_length_map[vt];
+	}
+
+	return 0;
+}
+
+static int parse_args(int argc, char *argv[])
+{
+	struct cmdline_vparm *vparm;
+	int i, err;
+	char *param;
+
+	parse_err = 0;
+	for (i = 1; i &lt; argc; i++) {
+		if (cmdargs.nr_vparm == MAX_VPARM) {
+			prerror(&quot;Too many value parameters.\n&quot;);
+			return -1;
+		}
+
+		if (arg_match(argv, &amp;i, &quot;--version&quot;, &quot;-v&quot;, 0)) {
+			print_banner(1);
+			return 1;
+		} else if (arg_match(argv, &amp;i, &quot;--help&quot;, &quot;-h&quot;, 0)) {
+			goto out_usage;
+		} else if (arg_match(argv, &amp;i, &quot;--input&quot;, &quot;-i&quot;, &amp;param)) {
+			cmdargs.infile = param;
+		} else if (arg_match(argv, &amp;i, &quot;--output&quot;, &quot;-o&quot;, &amp;param)) {
+			cmdargs.outfile = param;
+		} else if (arg_match(argv, &amp;i, &quot;--verbose&quot;, &quot;-V&quot;, 0)) {
+			cmdargs.verbose = 1;
+		} else if (arg_match(argv, &amp;i, &quot;--force&quot;, &quot;-n&quot;, 0)) {
+			cmdargs.force = 1;
+		} else if (arg_match(argv, &amp;i, &quot;--binmode&quot;, &quot;-b&quot;, 0)) {
+			cmdargs.bin_mode = 1;
+
+
+		} else if (arg_match(argv, &amp;i, &quot;--rawset&quot;, &quot;-s&quot;, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			err = parse_rawset(param, vparm);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--rawget&quot;, &quot;-g&quot;, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			err = parse_rawget(param, vparm);
+			if (err &lt; 0)
+				goto error;
+
+
+		} else if (arg_match(argv, &amp;i, &quot;--subp&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_SUBP;
+			err = parse_value(param, vparm, &quot;--subp&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--subv&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_SUBV;
+			err = parse_value(param, vparm, &quot;--subv&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--ppid&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_PPID;
+			err = parse_value(param, vparm, &quot;--ppid&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--bflhi&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_BFLHI;
+			err = parse_value(param, vparm, &quot;--bflhi&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--bfl&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_BFL;
+			err = parse_value(param, vparm, &quot;--bfl&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--bgmac&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_BGMAC;
+			err = parse_mac(param, vparm, &quot;--bgmac&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--etmac&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_ETMAC;
+			err = parse_mac(param, vparm, &quot;--etmac&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--amac&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_AMAC;
+			err = parse_mac(param, vparm, &quot;--amac&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--et0phy&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_ET0PHY;
+			err = parse_value(param, vparm, &quot;--et0phy&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--et1phy&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_ET1PHY;
+			err = parse_value(param, vparm, &quot;--et1phy&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--et0mdc&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_ET0MDC;
+			err = parse_value(param, vparm, &quot;--et0mdc&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--et1mdc&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_ET1MDC;
+			err = parse_value(param, vparm, &quot;--et1mdc&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--brev&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_BREV;
+			err = parse_value(param, vparm, &quot;--brev&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--loc&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_LOC;
+			err = parse_value(param, vparm, &quot;--loc&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--anta0&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_ANTA0;
+			err = parse_value(param, vparm, &quot;--anta0&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--anta1&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_ANTA1;
+			err = parse_value(param, vparm, &quot;--anta1&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--antbg0&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_ANTBG0;
+			err = parse_value(param, vparm, &quot;--antbg0&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--antbg1&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_ANTBG1;
+			err = parse_value(param, vparm, &quot;--antbg1&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--antga&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_ANTGA;
+			err = parse_value(param, vparm, &quot;--antga&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--antgbg&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_ANTGBG;
+			err = parse_value(param, vparm, &quot;--antgbg&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--pa0b0&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_PA0B0;
+			err = parse_value(param, vparm, &quot;--pa0b0&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--pa0b1&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_PA0B1;
+			err = parse_value(param, vparm, &quot;--pa0b1&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--pa0b2&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_PA0B2;
+			err = parse_value(param, vparm, &quot;--pa0b2&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--pa1b0&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_PA1B0;
+			err = parse_value(param, vparm, &quot;--pa1b0&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--pa1b1&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_PA1B1;
+			err = parse_value(param, vparm, &quot;--pa1b1&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--pa1b2&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_PA1B2;
+			err = parse_value(param, vparm, &quot;--pa1b2&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--wl0gpio0&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_WL0GPIO0;
+			err = parse_value(param, vparm, &quot;--wl0gpio0&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--wl0gpio1&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_WL0GPIO1;
+			err = parse_value(param, vparm, &quot;--wl0gpio1&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--wl0gpio2&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_WL0GPIO2;
+			err = parse_value(param, vparm, &quot;--wl0gpio2&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--wl0gpio3&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_WL0GPIO3;
+			err = parse_value(param, vparm, &quot;--wl0gpio3&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--maxpa&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_MAXPA;
+			err = parse_value(param, vparm, &quot;--maxpa&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--maxpbg&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_MAXPBG;
+			err = parse_value(param, vparm, &quot;--maxpbg&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--itssia&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_ITSSIA;
+			err = parse_value(param, vparm, &quot;--itssia&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--itssibg&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_ITSSIBG;
+			err = parse_value(param, vparm, &quot;--itssibg&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--sver&quot;, 0, &amp;param)) {
+			vparm = &amp;(cmdargs.vparm[cmdargs.nr_vparm++]);
+			vparm-&gt;type = VALUE_SVER;
+			err = parse_value(param, vparm, &quot;--sver&quot;);
+			if (err &lt; 0)
+				goto error;
+		} else if (arg_match(argv, &amp;i, &quot;--print-all&quot;, &quot;-P&quot;, 0)) {
+			err = generate_printall();
+			if (err)
+				goto error;
+		} else {
+			prerror(&quot;Unrecognized argument: %s\n&quot;, argv[i]);
+			goto out_usage;
+		}
+		if (parse_err)
+			goto out_usage;
+	}
+	if (cmdargs.nr_vparm == 0) {
+		prerror(&quot;No Value parameter given. See --help.\n&quot;);
+		return -1;
+	}
+	return 0;
+
+out_usage:
+	print_usage(argc, argv);
+error:
+	return -1;	
+}
+
+
+int main(int argc, char **argv)
+{
+	int err;
+	int fd;
+	uint8_t sprom[SPROM_SIZE];
+	char *buffer = NULL;
+	size_t buffer_size = 0;
+
+	err = parse_args(argc, argv);
+	if (err == 1)
+		return 0;
+	else if (err != 0)
+		goto out;
+
+	print_banner(0);
+	prinfo(&quot;\nReading input from \&quot;%s\&quot;...\n&quot;,
+	       cmdargs.infile ? cmdargs.infile : &quot;stdin&quot;);
+
+	err = open_infile(&amp;fd);
+	if (err)
+		goto out;
+	err = read_infile(fd, &amp;buffer, &amp;buffer_size);
+	close_infile(fd);
+	if (err)
+		goto out;
+	err = parse_input(sprom, buffer, buffer_size);
+	free(buffer);
+	if (err)
+		goto out;
+	err = validate_input(sprom);
+	if (err)
+		goto out;
+
+	err = display_sprom(sprom);
+	if (err)
+		goto out;
+	err = modify_sprom(sprom);
+	if (err &lt; 0)
+		goto out;
+	if (err) {
+		err = open_outfile(&amp;fd);
+		if (err)
+			goto out;
+		err = write_output(fd, sprom);
+		close_outfile(fd);
+		if (err)
+			goto out;
+		prinfo(&quot;SPROM modified.\n&quot;);
+	}
+out:
+	return err;
+}

Copied: trunk/sprom/ssb_sprom.h (from rev 1220, trunk/sprom/bcm43xx_sprom.h)
===================================================================
--- trunk/sprom/bcm43xx_sprom.h	2007-02-17 20:56:53 UTC (rev 1220)
+++ trunk/sprom/ssb_sprom.h	2007-02-17 21:05:03 UTC (rev 1221)
@@ -0,0 +1,126 @@
+/*
+
+  Broadcom Sonics Silicon Backplane bus SPROM data modification tool
+
+  Copyright (c) 2006-2007 Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-svn">mb at bu3sch.de</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; see the file COPYING.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Steet, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef SSB_SPROMTOOL_H_
+#define SSB_SPROMTOOL_H_
+
+#include &quot;utils.h&quot;
+
+#define VERSION			ssb_stringify(VERSION_)
+
+#define SPROM_SIZE		128 /* bytes */
+
+/* byte offsets */
+#define SPROM_SUBP		(0x02 * 2)
+#define SPROM_SUBV		(0x03 * 2)
+#define SPROM_PPID		(0x04 * 2)
+#define SPROM_BFLHI		(0x1C * 2)
+#define SPROM_IL0MACADDR	(0x24 * 2)
+#define SPROM_ET0MACADDR	(0x27 * 2)
+#define SPROM_ET1MACADDR	(0x2a * 2)
+#define SPROM_ETHPHY		(0x2d * 2)
+#define SPROM_BOARDREV		(0x2e * 2)
+#define SPROM_PA0B0		(0x2f * 2)
+#define SPROM_PA0B1		(0x30 * 2)
+#define SPROM_PA0B2		(0x31 * 2)
+#define SPROM_WL0GPIO0		(0x32 * 2)
+#define SPROM_WL0GPIO2		(0x33 * 2)
+#define SPROM_MAXPWR		(0x34 * 2)
+#define SPROM_PA1B0		(0x35 * 2)
+#define SPROM_PA1B1		(0x36 * 2)
+#define SPROM_PA1B2		(0x37 * 2)
+#define SPROM_IDL_TSSI_TGT	(0x38 * 2)
+#define SPROM_BOARDFLAGS	(0x39 * 2)
+#define SPROM_ANTENNA_GAIN	(0x3a * 2)
+#define SPROM_VERSION		(0x3f * 2)
+
+enum valuetype {
+	VALUE_RAW,
+
+	VALUE_SUBP,
+ VALUE_FIRST = VALUE_SUBP,
+	VALUE_SUBV,
+	VALUE_PPID,
+	VALUE_BFLHI,
+	VALUE_BFL,
+	VALUE_BGMAC,
+	VALUE_ETMAC,
+	VALUE_AMAC,
+	VALUE_ET0PHY,
+	VALUE_ET1PHY,
+	VALUE_ET0MDC,
+	VALUE_ET1MDC,
+	VALUE_BREV,
+	VALUE_LOC,
+	VALUE_ANTA0,
+	VALUE_ANTA1,
+	VALUE_ANTBG0,
+	VALUE_ANTBG1,
+	VALUE_ANTGA,
+	VALUE_ANTGBG,
+	VALUE_PA0B0,
+	VALUE_PA0B1,
+	VALUE_PA0B2,
+	VALUE_PA1B0,
+	VALUE_PA1B1,
+	VALUE_PA1B2,
+	VALUE_WL0GPIO0,
+	VALUE_WL0GPIO1,
+	VALUE_WL0GPIO2,
+	VALUE_WL0GPIO3,
+	VALUE_MAXPA,
+	VALUE_MAXPBG,
+	VALUE_ITSSIA,
+	VALUE_ITSSIBG,
+	VALUE_SVER,
+ VALUE_LAST = VALUE_SVER,
+};
+
+struct cmdline_vparm {
+	enum valuetype type;
+	int set;
+	int bits;
+	union {
+		uint16_t value;
+		uint8_t mac[6];
+		struct {
+			uint8_t value;
+			uint8_t offset;
+		} raw;
+	} u;
+};
+
+struct cmdline_args {
+	const char *infile;
+	const char *outfile;
+	int verbose;
+	int force;
+	int bin_mode;
+
+#define MAX_VPARM	512
+	struct cmdline_vparm vparm[MAX_VPARM];
+	int nr_vparm;
+};
+extern struct cmdline_args cmdargs;
+
+#endif /* SSB_SPROMTOOL_H_ */

Modified: trunk/sprom/utils.c
===================================================================
--- trunk/sprom/utils.c	2007-02-17 20:56:53 UTC (rev 1220)
+++ trunk/sprom/utils.c	2007-02-17 21:05:03 UTC (rev 1221)
@@ -1,8 +1,8 @@
 /*
 
-  Broadcom BCM43xx SPROM data modification tool
+  Broadcom Sonics Silicon Backplane bus SPROM data modification tool
 
-  Copyright (c) 2006 Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-svn">mbuesch at freenet.de</A>&gt;
+  Copyright (c) 2006-2007 Michael Buesch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/bcm43xx-svn">mb at bu3sch.de</A>&gt;
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -22,7 +22,7 @@
 */
 
 #include &quot;utils.h&quot;
-#include &quot;bcm43xx_sprom.h&quot;
+#include &quot;ssb_sprom.h&quot;
 
 #include &lt;string.h&gt;
 #include &lt;stdlib.h&gt;

Modified: trunk/sprom/utils.h
===================================================================
--- trunk/sprom/utils.h	2007-02-17 20:56:53 UTC (rev 1220)
+++ trunk/sprom/utils.h	2007-02-17 21:05:03 UTC (rev 1221)
@@ -1,12 +1,12 @@
-#ifndef BCM43xx_SPROMTOOL_UTILS_H_
-#define BCM43xx_SPROMTOOL_UTILS_H_
+#ifndef SSB_SPROMTOOL_UTILS_H_
+#define SSB_SPROMTOOL_UTILS_H_
 
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;stdint.h&gt;
 
-#define bcm43xx_stringify_1(x)	#x
-#define bcm43xx_stringify(x)	bcm43xx_stringify_1(x)
+#define ssb_stringify_1(x)	#x
+#define ssb_stringify(x)	ssb_stringify_1(x)
 
 #ifdef ATTRIBUTE_FORMAT
 # undef ATTRIBUTE_FORMAT
@@ -25,7 +25,7 @@
 #define internal_error_on(condition) \
 	do {								\
 		if (condition)						\
-			internal_error(bcm43xx_stringify(condition));	\
+			internal_error(ssb_stringify(condition));	\
 	} while (0)
 
 void * malloce(size_t size);
@@ -34,4 +34,4 @@
 /* CRC-8 with polynomial x^8+x^7+x^6+x^4+x^2+1 */
 uint8_t crc8(uint8_t crc, uint8_t data);
 
-#endif /* BCM43xx_SPROMTOOL_UTILS_H_ */
+#endif /* SSB_SPROMTOOL_UTILS_H_ */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000007.html">r1220 - trunk/sprom
</A></li>
	<LI>Next message: <A HREF="000009.html">r1222 - trunk/sprom
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8">[ date ]</a>
              <a href="thread.html#8">[ thread ]</a>
              <a href="subject.html#8">[ subject ]</a>
              <a href="author.html#8">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/bcm43xx-svn">More information about the Bcm43xx-svn
mailing list</a><br>
</body></html>
